// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sotskov-do/oms-assignment/internal/service/buildings.BuildingsService -o buildings_service_mock_test.go -n BuildingsServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sotskov-do/oms-assignment/internal/models"
)

// BuildingsServiceMock implements buildings.BuildingsService
type BuildingsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateBuilding          func(ctx context.Context, building *models.Building) (err error)
	inspectFuncCreateBuilding   func(ctx context.Context, building *models.Building)
	afterCreateBuildingCounter  uint64
	beforeCreateBuildingCounter uint64
	CreateBuildingMock          mBuildingsServiceMockCreateBuilding

	funcDeleteBuilding          func(ctx context.Context, id int) (err error)
	inspectFuncDeleteBuilding   func(ctx context.Context, id int)
	afterDeleteBuildingCounter  uint64
	beforeDeleteBuildingCounter uint64
	DeleteBuildingMock          mBuildingsServiceMockDeleteBuilding

	funcGetBuilding          func(ctx context.Context, id int) (bp1 *models.Building, err error)
	inspectFuncGetBuilding   func(ctx context.Context, id int)
	afterGetBuildingCounter  uint64
	beforeGetBuildingCounter uint64
	GetBuildingMock          mBuildingsServiceMockGetBuilding

	funcGetBuildings          func(ctx context.Context) (b1 models.BuildingSlice, err error)
	inspectFuncGetBuildings   func(ctx context.Context)
	afterGetBuildingsCounter  uint64
	beforeGetBuildingsCounter uint64
	GetBuildingsMock          mBuildingsServiceMockGetBuildings
}

// NewBuildingsServiceMock returns a mock for buildings.BuildingsService
func NewBuildingsServiceMock(t minimock.Tester) *BuildingsServiceMock {
	m := &BuildingsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBuildingMock = mBuildingsServiceMockCreateBuilding{mock: m}
	m.CreateBuildingMock.callArgs = []*BuildingsServiceMockCreateBuildingParams{}

	m.DeleteBuildingMock = mBuildingsServiceMockDeleteBuilding{mock: m}
	m.DeleteBuildingMock.callArgs = []*BuildingsServiceMockDeleteBuildingParams{}

	m.GetBuildingMock = mBuildingsServiceMockGetBuilding{mock: m}
	m.GetBuildingMock.callArgs = []*BuildingsServiceMockGetBuildingParams{}

	m.GetBuildingsMock = mBuildingsServiceMockGetBuildings{mock: m}
	m.GetBuildingsMock.callArgs = []*BuildingsServiceMockGetBuildingsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBuildingsServiceMockCreateBuilding struct {
	optional           bool
	mock               *BuildingsServiceMock
	defaultExpectation *BuildingsServiceMockCreateBuildingExpectation
	expectations       []*BuildingsServiceMockCreateBuildingExpectation

	callArgs []*BuildingsServiceMockCreateBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsServiceMockCreateBuildingExpectation specifies expectation struct of the BuildingsService.CreateBuilding
type BuildingsServiceMockCreateBuildingExpectation struct {
	mock      *BuildingsServiceMock
	params    *BuildingsServiceMockCreateBuildingParams
	paramPtrs *BuildingsServiceMockCreateBuildingParamPtrs
	results   *BuildingsServiceMockCreateBuildingResults
	Counter   uint64
}

// BuildingsServiceMockCreateBuildingParams contains parameters of the BuildingsService.CreateBuilding
type BuildingsServiceMockCreateBuildingParams struct {
	ctx      context.Context
	building *models.Building
}

// BuildingsServiceMockCreateBuildingParamPtrs contains pointers to parameters of the BuildingsService.CreateBuilding
type BuildingsServiceMockCreateBuildingParamPtrs struct {
	ctx      *context.Context
	building **models.Building
}

// BuildingsServiceMockCreateBuildingResults contains results of the BuildingsService.CreateBuilding
type BuildingsServiceMockCreateBuildingResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Optional() *mBuildingsServiceMockCreateBuilding {
	mmCreateBuilding.optional = true
	return mmCreateBuilding
}

// Expect sets up expected params for BuildingsService.CreateBuilding
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Expect(ctx context.Context, building *models.Building) *mBuildingsServiceMockCreateBuilding {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsServiceMockCreateBuildingExpectation{}
	}

	if mmCreateBuilding.defaultExpectation.paramPtrs != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by ExpectParams functions")
	}

	mmCreateBuilding.defaultExpectation.params = &BuildingsServiceMockCreateBuildingParams{ctx, building}
	for _, e := range mmCreateBuilding.expectations {
		if minimock.Equal(e.params, mmCreateBuilding.defaultExpectation.params) {
			mmCreateBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBuilding.defaultExpectation.params)
		}
	}

	return mmCreateBuilding
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsService.CreateBuilding
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) ExpectCtxParam1(ctx context.Context) *mBuildingsServiceMockCreateBuilding {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsServiceMockCreateBuildingExpectation{}
	}

	if mmCreateBuilding.defaultExpectation.params != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Expect")
	}

	if mmCreateBuilding.defaultExpectation.paramPtrs == nil {
		mmCreateBuilding.defaultExpectation.paramPtrs = &BuildingsServiceMockCreateBuildingParamPtrs{}
	}
	mmCreateBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateBuilding
}

// ExpectBuildingParam2 sets up expected param building for BuildingsService.CreateBuilding
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) ExpectBuildingParam2(building *models.Building) *mBuildingsServiceMockCreateBuilding {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsServiceMockCreateBuildingExpectation{}
	}

	if mmCreateBuilding.defaultExpectation.params != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Expect")
	}

	if mmCreateBuilding.defaultExpectation.paramPtrs == nil {
		mmCreateBuilding.defaultExpectation.paramPtrs = &BuildingsServiceMockCreateBuildingParamPtrs{}
	}
	mmCreateBuilding.defaultExpectation.paramPtrs.building = &building

	return mmCreateBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingsService.CreateBuilding
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Inspect(f func(ctx context.Context, building *models.Building)) *mBuildingsServiceMockCreateBuilding {
	if mmCreateBuilding.mock.inspectFuncCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("Inspect function is already set for BuildingsServiceMock.CreateBuilding")
	}

	mmCreateBuilding.mock.inspectFuncCreateBuilding = f

	return mmCreateBuilding
}

// Return sets up results that will be returned by BuildingsService.CreateBuilding
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Return(err error) *BuildingsServiceMock {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsServiceMockCreateBuildingExpectation{mock: mmCreateBuilding.mock}
	}
	mmCreateBuilding.defaultExpectation.results = &BuildingsServiceMockCreateBuildingResults{err}
	return mmCreateBuilding.mock
}

// Set uses given function f to mock the BuildingsService.CreateBuilding method
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Set(f func(ctx context.Context, building *models.Building) (err error)) *BuildingsServiceMock {
	if mmCreateBuilding.defaultExpectation != nil {
		mmCreateBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingsService.CreateBuilding method")
	}

	if len(mmCreateBuilding.expectations) > 0 {
		mmCreateBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingsService.CreateBuilding method")
	}

	mmCreateBuilding.mock.funcCreateBuilding = f
	return mmCreateBuilding.mock
}

// When sets expectation for the BuildingsService.CreateBuilding which will trigger the result defined by the following
// Then helper
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) When(ctx context.Context, building *models.Building) *BuildingsServiceMockCreateBuildingExpectation {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsServiceMock.CreateBuilding mock is already set by Set")
	}

	expectation := &BuildingsServiceMockCreateBuildingExpectation{
		mock:   mmCreateBuilding.mock,
		params: &BuildingsServiceMockCreateBuildingParams{ctx, building},
	}
	mmCreateBuilding.expectations = append(mmCreateBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingsService.CreateBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingsServiceMockCreateBuildingExpectation) Then(err error) *BuildingsServiceMock {
	e.results = &BuildingsServiceMockCreateBuildingResults{err}
	return e.mock
}

// Times sets number of times BuildingsService.CreateBuilding should be invoked
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Times(n uint64) *mBuildingsServiceMockCreateBuilding {
	if n == 0 {
		mmCreateBuilding.mock.t.Fatalf("Times of BuildingsServiceMock.CreateBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateBuilding.expectedInvocations, n)
	return mmCreateBuilding
}

func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) invocationsDone() bool {
	if len(mmCreateBuilding.expectations) == 0 && mmCreateBuilding.defaultExpectation == nil && mmCreateBuilding.mock.funcCreateBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateBuilding.mock.afterCreateBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateBuilding implements buildings.BuildingsService
func (mmCreateBuilding *BuildingsServiceMock) CreateBuilding(ctx context.Context, building *models.Building) (err error) {
	mm_atomic.AddUint64(&mmCreateBuilding.beforeCreateBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBuilding.afterCreateBuildingCounter, 1)

	if mmCreateBuilding.inspectFuncCreateBuilding != nil {
		mmCreateBuilding.inspectFuncCreateBuilding(ctx, building)
	}

	mm_params := BuildingsServiceMockCreateBuildingParams{ctx, building}

	// Record call args
	mmCreateBuilding.CreateBuildingMock.mutex.Lock()
	mmCreateBuilding.CreateBuildingMock.callArgs = append(mmCreateBuilding.CreateBuildingMock.callArgs, &mm_params)
	mmCreateBuilding.CreateBuildingMock.mutex.Unlock()

	for _, e := range mmCreateBuilding.CreateBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateBuilding.CreateBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBuilding.CreateBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBuilding.CreateBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmCreateBuilding.CreateBuildingMock.defaultExpectation.paramPtrs

		mm_got := BuildingsServiceMockCreateBuildingParams{ctx, building}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateBuilding.t.Errorf("BuildingsServiceMock.CreateBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.building != nil && !minimock.Equal(*mm_want_ptrs.building, mm_got.building) {
				mmCreateBuilding.t.Errorf("BuildingsServiceMock.CreateBuilding got unexpected parameter building, want: %#v, got: %#v%s\n", *mm_want_ptrs.building, mm_got.building, minimock.Diff(*mm_want_ptrs.building, mm_got.building))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBuilding.t.Errorf("BuildingsServiceMock.CreateBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBuilding.CreateBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBuilding.t.Fatal("No results are set for the BuildingsServiceMock.CreateBuilding")
		}
		return (*mm_results).err
	}
	if mmCreateBuilding.funcCreateBuilding != nil {
		return mmCreateBuilding.funcCreateBuilding(ctx, building)
	}
	mmCreateBuilding.t.Fatalf("Unexpected call to BuildingsServiceMock.CreateBuilding. %v %v", ctx, building)
	return
}

// CreateBuildingAfterCounter returns a count of finished BuildingsServiceMock.CreateBuilding invocations
func (mmCreateBuilding *BuildingsServiceMock) CreateBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilding.afterCreateBuildingCounter)
}

// CreateBuildingBeforeCounter returns a count of BuildingsServiceMock.CreateBuilding invocations
func (mmCreateBuilding *BuildingsServiceMock) CreateBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilding.beforeCreateBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingsServiceMock.CreateBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBuilding *mBuildingsServiceMockCreateBuilding) Calls() []*BuildingsServiceMockCreateBuildingParams {
	mmCreateBuilding.mutex.RLock()

	argCopy := make([]*BuildingsServiceMockCreateBuildingParams, len(mmCreateBuilding.callArgs))
	copy(argCopy, mmCreateBuilding.callArgs)

	mmCreateBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBuildingDone returns true if the count of the CreateBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingsServiceMock) MinimockCreateBuildingDone() bool {
	if m.CreateBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateBuildingMock.invocationsDone()
}

// MinimockCreateBuildingInspect logs each unmet expectation
func (m *BuildingsServiceMock) MinimockCreateBuildingInspect() {
	for _, e := range m.CreateBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsServiceMock.CreateBuilding with params: %#v", *e.params)
		}
	}

	afterCreateBuildingCounter := mm_atomic.LoadUint64(&m.afterCreateBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBuildingMock.defaultExpectation != nil && afterCreateBuildingCounter < 1 {
		if m.CreateBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsServiceMock.CreateBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingsServiceMock.CreateBuilding with params: %#v", *m.CreateBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBuilding != nil && afterCreateBuildingCounter < 1 {
		m.t.Error("Expected call to BuildingsServiceMock.CreateBuilding")
	}

	if !m.CreateBuildingMock.invocationsDone() && afterCreateBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsServiceMock.CreateBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.CreateBuildingMock.expectedInvocations), afterCreateBuildingCounter)
	}
}

type mBuildingsServiceMockDeleteBuilding struct {
	optional           bool
	mock               *BuildingsServiceMock
	defaultExpectation *BuildingsServiceMockDeleteBuildingExpectation
	expectations       []*BuildingsServiceMockDeleteBuildingExpectation

	callArgs []*BuildingsServiceMockDeleteBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsServiceMockDeleteBuildingExpectation specifies expectation struct of the BuildingsService.DeleteBuilding
type BuildingsServiceMockDeleteBuildingExpectation struct {
	mock      *BuildingsServiceMock
	params    *BuildingsServiceMockDeleteBuildingParams
	paramPtrs *BuildingsServiceMockDeleteBuildingParamPtrs
	results   *BuildingsServiceMockDeleteBuildingResults
	Counter   uint64
}

// BuildingsServiceMockDeleteBuildingParams contains parameters of the BuildingsService.DeleteBuilding
type BuildingsServiceMockDeleteBuildingParams struct {
	ctx context.Context
	id  int
}

// BuildingsServiceMockDeleteBuildingParamPtrs contains pointers to parameters of the BuildingsService.DeleteBuilding
type BuildingsServiceMockDeleteBuildingParamPtrs struct {
	ctx *context.Context
	id  *int
}

// BuildingsServiceMockDeleteBuildingResults contains results of the BuildingsService.DeleteBuilding
type BuildingsServiceMockDeleteBuildingResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Optional() *mBuildingsServiceMockDeleteBuilding {
	mmDeleteBuilding.optional = true
	return mmDeleteBuilding
}

// Expect sets up expected params for BuildingsService.DeleteBuilding
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Expect(ctx context.Context, id int) *mBuildingsServiceMockDeleteBuilding {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsServiceMockDeleteBuildingExpectation{}
	}

	if mmDeleteBuilding.defaultExpectation.paramPtrs != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by ExpectParams functions")
	}

	mmDeleteBuilding.defaultExpectation.params = &BuildingsServiceMockDeleteBuildingParams{ctx, id}
	for _, e := range mmDeleteBuilding.expectations {
		if minimock.Equal(e.params, mmDeleteBuilding.defaultExpectation.params) {
			mmDeleteBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBuilding.defaultExpectation.params)
		}
	}

	return mmDeleteBuilding
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsService.DeleteBuilding
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) ExpectCtxParam1(ctx context.Context) *mBuildingsServiceMockDeleteBuilding {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsServiceMockDeleteBuildingExpectation{}
	}

	if mmDeleteBuilding.defaultExpectation.params != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Expect")
	}

	if mmDeleteBuilding.defaultExpectation.paramPtrs == nil {
		mmDeleteBuilding.defaultExpectation.paramPtrs = &BuildingsServiceMockDeleteBuildingParamPtrs{}
	}
	mmDeleteBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteBuilding
}

// ExpectIdParam2 sets up expected param id for BuildingsService.DeleteBuilding
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) ExpectIdParam2(id int) *mBuildingsServiceMockDeleteBuilding {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsServiceMockDeleteBuildingExpectation{}
	}

	if mmDeleteBuilding.defaultExpectation.params != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Expect")
	}

	if mmDeleteBuilding.defaultExpectation.paramPtrs == nil {
		mmDeleteBuilding.defaultExpectation.paramPtrs = &BuildingsServiceMockDeleteBuildingParamPtrs{}
	}
	mmDeleteBuilding.defaultExpectation.paramPtrs.id = &id

	return mmDeleteBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingsService.DeleteBuilding
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Inspect(f func(ctx context.Context, id int)) *mBuildingsServiceMockDeleteBuilding {
	if mmDeleteBuilding.mock.inspectFuncDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("Inspect function is already set for BuildingsServiceMock.DeleteBuilding")
	}

	mmDeleteBuilding.mock.inspectFuncDeleteBuilding = f

	return mmDeleteBuilding
}

// Return sets up results that will be returned by BuildingsService.DeleteBuilding
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Return(err error) *BuildingsServiceMock {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsServiceMockDeleteBuildingExpectation{mock: mmDeleteBuilding.mock}
	}
	mmDeleteBuilding.defaultExpectation.results = &BuildingsServiceMockDeleteBuildingResults{err}
	return mmDeleteBuilding.mock
}

// Set uses given function f to mock the BuildingsService.DeleteBuilding method
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Set(f func(ctx context.Context, id int) (err error)) *BuildingsServiceMock {
	if mmDeleteBuilding.defaultExpectation != nil {
		mmDeleteBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingsService.DeleteBuilding method")
	}

	if len(mmDeleteBuilding.expectations) > 0 {
		mmDeleteBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingsService.DeleteBuilding method")
	}

	mmDeleteBuilding.mock.funcDeleteBuilding = f
	return mmDeleteBuilding.mock
}

// When sets expectation for the BuildingsService.DeleteBuilding which will trigger the result defined by the following
// Then helper
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) When(ctx context.Context, id int) *BuildingsServiceMockDeleteBuildingExpectation {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsServiceMock.DeleteBuilding mock is already set by Set")
	}

	expectation := &BuildingsServiceMockDeleteBuildingExpectation{
		mock:   mmDeleteBuilding.mock,
		params: &BuildingsServiceMockDeleteBuildingParams{ctx, id},
	}
	mmDeleteBuilding.expectations = append(mmDeleteBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingsService.DeleteBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingsServiceMockDeleteBuildingExpectation) Then(err error) *BuildingsServiceMock {
	e.results = &BuildingsServiceMockDeleteBuildingResults{err}
	return e.mock
}

// Times sets number of times BuildingsService.DeleteBuilding should be invoked
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Times(n uint64) *mBuildingsServiceMockDeleteBuilding {
	if n == 0 {
		mmDeleteBuilding.mock.t.Fatalf("Times of BuildingsServiceMock.DeleteBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteBuilding.expectedInvocations, n)
	return mmDeleteBuilding
}

func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) invocationsDone() bool {
	if len(mmDeleteBuilding.expectations) == 0 && mmDeleteBuilding.defaultExpectation == nil && mmDeleteBuilding.mock.funcDeleteBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteBuilding.mock.afterDeleteBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteBuilding implements buildings.BuildingsService
func (mmDeleteBuilding *BuildingsServiceMock) DeleteBuilding(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteBuilding.beforeDeleteBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBuilding.afterDeleteBuildingCounter, 1)

	if mmDeleteBuilding.inspectFuncDeleteBuilding != nil {
		mmDeleteBuilding.inspectFuncDeleteBuilding(ctx, id)
	}

	mm_params := BuildingsServiceMockDeleteBuildingParams{ctx, id}

	// Record call args
	mmDeleteBuilding.DeleteBuildingMock.mutex.Lock()
	mmDeleteBuilding.DeleteBuildingMock.callArgs = append(mmDeleteBuilding.DeleteBuildingMock.callArgs, &mm_params)
	mmDeleteBuilding.DeleteBuildingMock.mutex.Unlock()

	for _, e := range mmDeleteBuilding.DeleteBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteBuilding.DeleteBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.paramPtrs

		mm_got := BuildingsServiceMockDeleteBuildingParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteBuilding.t.Errorf("BuildingsServiceMock.DeleteBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteBuilding.t.Errorf("BuildingsServiceMock.DeleteBuilding got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBuilding.t.Errorf("BuildingsServiceMock.DeleteBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBuilding.t.Fatal("No results are set for the BuildingsServiceMock.DeleteBuilding")
		}
		return (*mm_results).err
	}
	if mmDeleteBuilding.funcDeleteBuilding != nil {
		return mmDeleteBuilding.funcDeleteBuilding(ctx, id)
	}
	mmDeleteBuilding.t.Fatalf("Unexpected call to BuildingsServiceMock.DeleteBuilding. %v %v", ctx, id)
	return
}

// DeleteBuildingAfterCounter returns a count of finished BuildingsServiceMock.DeleteBuilding invocations
func (mmDeleteBuilding *BuildingsServiceMock) DeleteBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBuilding.afterDeleteBuildingCounter)
}

// DeleteBuildingBeforeCounter returns a count of BuildingsServiceMock.DeleteBuilding invocations
func (mmDeleteBuilding *BuildingsServiceMock) DeleteBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBuilding.beforeDeleteBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingsServiceMock.DeleteBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBuilding *mBuildingsServiceMockDeleteBuilding) Calls() []*BuildingsServiceMockDeleteBuildingParams {
	mmDeleteBuilding.mutex.RLock()

	argCopy := make([]*BuildingsServiceMockDeleteBuildingParams, len(mmDeleteBuilding.callArgs))
	copy(argCopy, mmDeleteBuilding.callArgs)

	mmDeleteBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBuildingDone returns true if the count of the DeleteBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingsServiceMock) MinimockDeleteBuildingDone() bool {
	if m.DeleteBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteBuildingMock.invocationsDone()
}

// MinimockDeleteBuildingInspect logs each unmet expectation
func (m *BuildingsServiceMock) MinimockDeleteBuildingInspect() {
	for _, e := range m.DeleteBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsServiceMock.DeleteBuilding with params: %#v", *e.params)
		}
	}

	afterDeleteBuildingCounter := mm_atomic.LoadUint64(&m.afterDeleteBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBuildingMock.defaultExpectation != nil && afterDeleteBuildingCounter < 1 {
		if m.DeleteBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsServiceMock.DeleteBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingsServiceMock.DeleteBuilding with params: %#v", *m.DeleteBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBuilding != nil && afterDeleteBuildingCounter < 1 {
		m.t.Error("Expected call to BuildingsServiceMock.DeleteBuilding")
	}

	if !m.DeleteBuildingMock.invocationsDone() && afterDeleteBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsServiceMock.DeleteBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteBuildingMock.expectedInvocations), afterDeleteBuildingCounter)
	}
}

type mBuildingsServiceMockGetBuilding struct {
	optional           bool
	mock               *BuildingsServiceMock
	defaultExpectation *BuildingsServiceMockGetBuildingExpectation
	expectations       []*BuildingsServiceMockGetBuildingExpectation

	callArgs []*BuildingsServiceMockGetBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsServiceMockGetBuildingExpectation specifies expectation struct of the BuildingsService.GetBuilding
type BuildingsServiceMockGetBuildingExpectation struct {
	mock      *BuildingsServiceMock
	params    *BuildingsServiceMockGetBuildingParams
	paramPtrs *BuildingsServiceMockGetBuildingParamPtrs
	results   *BuildingsServiceMockGetBuildingResults
	Counter   uint64
}

// BuildingsServiceMockGetBuildingParams contains parameters of the BuildingsService.GetBuilding
type BuildingsServiceMockGetBuildingParams struct {
	ctx context.Context
	id  int
}

// BuildingsServiceMockGetBuildingParamPtrs contains pointers to parameters of the BuildingsService.GetBuilding
type BuildingsServiceMockGetBuildingParamPtrs struct {
	ctx *context.Context
	id  *int
}

// BuildingsServiceMockGetBuildingResults contains results of the BuildingsService.GetBuilding
type BuildingsServiceMockGetBuildingResults struct {
	bp1 *models.Building
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Optional() *mBuildingsServiceMockGetBuilding {
	mmGetBuilding.optional = true
	return mmGetBuilding
}

// Expect sets up expected params for BuildingsService.GetBuilding
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Expect(ctx context.Context, id int) *mBuildingsServiceMockGetBuilding {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsServiceMockGetBuildingExpectation{}
	}

	if mmGetBuilding.defaultExpectation.paramPtrs != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by ExpectParams functions")
	}

	mmGetBuilding.defaultExpectation.params = &BuildingsServiceMockGetBuildingParams{ctx, id}
	for _, e := range mmGetBuilding.expectations {
		if minimock.Equal(e.params, mmGetBuilding.defaultExpectation.params) {
			mmGetBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBuilding.defaultExpectation.params)
		}
	}

	return mmGetBuilding
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsService.GetBuilding
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) ExpectCtxParam1(ctx context.Context) *mBuildingsServiceMockGetBuilding {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsServiceMockGetBuildingExpectation{}
	}

	if mmGetBuilding.defaultExpectation.params != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Expect")
	}

	if mmGetBuilding.defaultExpectation.paramPtrs == nil {
		mmGetBuilding.defaultExpectation.paramPtrs = &BuildingsServiceMockGetBuildingParamPtrs{}
	}
	mmGetBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBuilding
}

// ExpectIdParam2 sets up expected param id for BuildingsService.GetBuilding
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) ExpectIdParam2(id int) *mBuildingsServiceMockGetBuilding {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsServiceMockGetBuildingExpectation{}
	}

	if mmGetBuilding.defaultExpectation.params != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Expect")
	}

	if mmGetBuilding.defaultExpectation.paramPtrs == nil {
		mmGetBuilding.defaultExpectation.paramPtrs = &BuildingsServiceMockGetBuildingParamPtrs{}
	}
	mmGetBuilding.defaultExpectation.paramPtrs.id = &id

	return mmGetBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingsService.GetBuilding
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Inspect(f func(ctx context.Context, id int)) *mBuildingsServiceMockGetBuilding {
	if mmGetBuilding.mock.inspectFuncGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("Inspect function is already set for BuildingsServiceMock.GetBuilding")
	}

	mmGetBuilding.mock.inspectFuncGetBuilding = f

	return mmGetBuilding
}

// Return sets up results that will be returned by BuildingsService.GetBuilding
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Return(bp1 *models.Building, err error) *BuildingsServiceMock {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsServiceMockGetBuildingExpectation{mock: mmGetBuilding.mock}
	}
	mmGetBuilding.defaultExpectation.results = &BuildingsServiceMockGetBuildingResults{bp1, err}
	return mmGetBuilding.mock
}

// Set uses given function f to mock the BuildingsService.GetBuilding method
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Set(f func(ctx context.Context, id int) (bp1 *models.Building, err error)) *BuildingsServiceMock {
	if mmGetBuilding.defaultExpectation != nil {
		mmGetBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingsService.GetBuilding method")
	}

	if len(mmGetBuilding.expectations) > 0 {
		mmGetBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingsService.GetBuilding method")
	}

	mmGetBuilding.mock.funcGetBuilding = f
	return mmGetBuilding.mock
}

// When sets expectation for the BuildingsService.GetBuilding which will trigger the result defined by the following
// Then helper
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) When(ctx context.Context, id int) *BuildingsServiceMockGetBuildingExpectation {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsServiceMock.GetBuilding mock is already set by Set")
	}

	expectation := &BuildingsServiceMockGetBuildingExpectation{
		mock:   mmGetBuilding.mock,
		params: &BuildingsServiceMockGetBuildingParams{ctx, id},
	}
	mmGetBuilding.expectations = append(mmGetBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingsService.GetBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingsServiceMockGetBuildingExpectation) Then(bp1 *models.Building, err error) *BuildingsServiceMock {
	e.results = &BuildingsServiceMockGetBuildingResults{bp1, err}
	return e.mock
}

// Times sets number of times BuildingsService.GetBuilding should be invoked
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Times(n uint64) *mBuildingsServiceMockGetBuilding {
	if n == 0 {
		mmGetBuilding.mock.t.Fatalf("Times of BuildingsServiceMock.GetBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBuilding.expectedInvocations, n)
	return mmGetBuilding
}

func (mmGetBuilding *mBuildingsServiceMockGetBuilding) invocationsDone() bool {
	if len(mmGetBuilding.expectations) == 0 && mmGetBuilding.defaultExpectation == nil && mmGetBuilding.mock.funcGetBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBuilding.mock.afterGetBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBuilding implements buildings.BuildingsService
func (mmGetBuilding *BuildingsServiceMock) GetBuilding(ctx context.Context, id int) (bp1 *models.Building, err error) {
	mm_atomic.AddUint64(&mmGetBuilding.beforeGetBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBuilding.afterGetBuildingCounter, 1)

	if mmGetBuilding.inspectFuncGetBuilding != nil {
		mmGetBuilding.inspectFuncGetBuilding(ctx, id)
	}

	mm_params := BuildingsServiceMockGetBuildingParams{ctx, id}

	// Record call args
	mmGetBuilding.GetBuildingMock.mutex.Lock()
	mmGetBuilding.GetBuildingMock.callArgs = append(mmGetBuilding.GetBuildingMock.callArgs, &mm_params)
	mmGetBuilding.GetBuildingMock.mutex.Unlock()

	for _, e := range mmGetBuilding.GetBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBuilding.GetBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBuilding.GetBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBuilding.GetBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmGetBuilding.GetBuildingMock.defaultExpectation.paramPtrs

		mm_got := BuildingsServiceMockGetBuildingParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBuilding.t.Errorf("BuildingsServiceMock.GetBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetBuilding.t.Errorf("BuildingsServiceMock.GetBuilding got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBuilding.t.Errorf("BuildingsServiceMock.GetBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBuilding.GetBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBuilding.t.Fatal("No results are set for the BuildingsServiceMock.GetBuilding")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBuilding.funcGetBuilding != nil {
		return mmGetBuilding.funcGetBuilding(ctx, id)
	}
	mmGetBuilding.t.Fatalf("Unexpected call to BuildingsServiceMock.GetBuilding. %v %v", ctx, id)
	return
}

// GetBuildingAfterCounter returns a count of finished BuildingsServiceMock.GetBuilding invocations
func (mmGetBuilding *BuildingsServiceMock) GetBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuilding.afterGetBuildingCounter)
}

// GetBuildingBeforeCounter returns a count of BuildingsServiceMock.GetBuilding invocations
func (mmGetBuilding *BuildingsServiceMock) GetBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuilding.beforeGetBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingsServiceMock.GetBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBuilding *mBuildingsServiceMockGetBuilding) Calls() []*BuildingsServiceMockGetBuildingParams {
	mmGetBuilding.mutex.RLock()

	argCopy := make([]*BuildingsServiceMockGetBuildingParams, len(mmGetBuilding.callArgs))
	copy(argCopy, mmGetBuilding.callArgs)

	mmGetBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockGetBuildingDone returns true if the count of the GetBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingsServiceMock) MinimockGetBuildingDone() bool {
	if m.GetBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBuildingMock.invocationsDone()
}

// MinimockGetBuildingInspect logs each unmet expectation
func (m *BuildingsServiceMock) MinimockGetBuildingInspect() {
	for _, e := range m.GetBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsServiceMock.GetBuilding with params: %#v", *e.params)
		}
	}

	afterGetBuildingCounter := mm_atomic.LoadUint64(&m.afterGetBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBuildingMock.defaultExpectation != nil && afterGetBuildingCounter < 1 {
		if m.GetBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsServiceMock.GetBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingsServiceMock.GetBuilding with params: %#v", *m.GetBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBuilding != nil && afterGetBuildingCounter < 1 {
		m.t.Error("Expected call to BuildingsServiceMock.GetBuilding")
	}

	if !m.GetBuildingMock.invocationsDone() && afterGetBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsServiceMock.GetBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.GetBuildingMock.expectedInvocations), afterGetBuildingCounter)
	}
}

type mBuildingsServiceMockGetBuildings struct {
	optional           bool
	mock               *BuildingsServiceMock
	defaultExpectation *BuildingsServiceMockGetBuildingsExpectation
	expectations       []*BuildingsServiceMockGetBuildingsExpectation

	callArgs []*BuildingsServiceMockGetBuildingsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsServiceMockGetBuildingsExpectation specifies expectation struct of the BuildingsService.GetBuildings
type BuildingsServiceMockGetBuildingsExpectation struct {
	mock      *BuildingsServiceMock
	params    *BuildingsServiceMockGetBuildingsParams
	paramPtrs *BuildingsServiceMockGetBuildingsParamPtrs
	results   *BuildingsServiceMockGetBuildingsResults
	Counter   uint64
}

// BuildingsServiceMockGetBuildingsParams contains parameters of the BuildingsService.GetBuildings
type BuildingsServiceMockGetBuildingsParams struct {
	ctx context.Context
}

// BuildingsServiceMockGetBuildingsParamPtrs contains pointers to parameters of the BuildingsService.GetBuildings
type BuildingsServiceMockGetBuildingsParamPtrs struct {
	ctx *context.Context
}

// BuildingsServiceMockGetBuildingsResults contains results of the BuildingsService.GetBuildings
type BuildingsServiceMockGetBuildingsResults struct {
	b1  models.BuildingSlice
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Optional() *mBuildingsServiceMockGetBuildings {
	mmGetBuildings.optional = true
	return mmGetBuildings
}

// Expect sets up expected params for BuildingsService.GetBuildings
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Expect(ctx context.Context) *mBuildingsServiceMockGetBuildings {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsServiceMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingsServiceMockGetBuildingsExpectation{}
	}

	if mmGetBuildings.defaultExpectation.paramPtrs != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsServiceMock.GetBuildings mock is already set by ExpectParams functions")
	}

	mmGetBuildings.defaultExpectation.params = &BuildingsServiceMockGetBuildingsParams{ctx}
	for _, e := range mmGetBuildings.expectations {
		if minimock.Equal(e.params, mmGetBuildings.defaultExpectation.params) {
			mmGetBuildings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBuildings.defaultExpectation.params)
		}
	}

	return mmGetBuildings
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsService.GetBuildings
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) ExpectCtxParam1(ctx context.Context) *mBuildingsServiceMockGetBuildings {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsServiceMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingsServiceMockGetBuildingsExpectation{}
	}

	if mmGetBuildings.defaultExpectation.params != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsServiceMock.GetBuildings mock is already set by Expect")
	}

	if mmGetBuildings.defaultExpectation.paramPtrs == nil {
		mmGetBuildings.defaultExpectation.paramPtrs = &BuildingsServiceMockGetBuildingsParamPtrs{}
	}
	mmGetBuildings.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBuildings
}

// Inspect accepts an inspector function that has same arguments as the BuildingsService.GetBuildings
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Inspect(f func(ctx context.Context)) *mBuildingsServiceMockGetBuildings {
	if mmGetBuildings.mock.inspectFuncGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("Inspect function is already set for BuildingsServiceMock.GetBuildings")
	}

	mmGetBuildings.mock.inspectFuncGetBuildings = f

	return mmGetBuildings
}

// Return sets up results that will be returned by BuildingsService.GetBuildings
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Return(b1 models.BuildingSlice, err error) *BuildingsServiceMock {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsServiceMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingsServiceMockGetBuildingsExpectation{mock: mmGetBuildings.mock}
	}
	mmGetBuildings.defaultExpectation.results = &BuildingsServiceMockGetBuildingsResults{b1, err}
	return mmGetBuildings.mock
}

// Set uses given function f to mock the BuildingsService.GetBuildings method
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Set(f func(ctx context.Context) (b1 models.BuildingSlice, err error)) *BuildingsServiceMock {
	if mmGetBuildings.defaultExpectation != nil {
		mmGetBuildings.mock.t.Fatalf("Default expectation is already set for the BuildingsService.GetBuildings method")
	}

	if len(mmGetBuildings.expectations) > 0 {
		mmGetBuildings.mock.t.Fatalf("Some expectations are already set for the BuildingsService.GetBuildings method")
	}

	mmGetBuildings.mock.funcGetBuildings = f
	return mmGetBuildings.mock
}

// When sets expectation for the BuildingsService.GetBuildings which will trigger the result defined by the following
// Then helper
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) When(ctx context.Context) *BuildingsServiceMockGetBuildingsExpectation {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsServiceMock.GetBuildings mock is already set by Set")
	}

	expectation := &BuildingsServiceMockGetBuildingsExpectation{
		mock:   mmGetBuildings.mock,
		params: &BuildingsServiceMockGetBuildingsParams{ctx},
	}
	mmGetBuildings.expectations = append(mmGetBuildings.expectations, expectation)
	return expectation
}

// Then sets up BuildingsService.GetBuildings return parameters for the expectation previously defined by the When method
func (e *BuildingsServiceMockGetBuildingsExpectation) Then(b1 models.BuildingSlice, err error) *BuildingsServiceMock {
	e.results = &BuildingsServiceMockGetBuildingsResults{b1, err}
	return e.mock
}

// Times sets number of times BuildingsService.GetBuildings should be invoked
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Times(n uint64) *mBuildingsServiceMockGetBuildings {
	if n == 0 {
		mmGetBuildings.mock.t.Fatalf("Times of BuildingsServiceMock.GetBuildings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBuildings.expectedInvocations, n)
	return mmGetBuildings
}

func (mmGetBuildings *mBuildingsServiceMockGetBuildings) invocationsDone() bool {
	if len(mmGetBuildings.expectations) == 0 && mmGetBuildings.defaultExpectation == nil && mmGetBuildings.mock.funcGetBuildings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBuildings.mock.afterGetBuildingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBuildings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBuildings implements buildings.BuildingsService
func (mmGetBuildings *BuildingsServiceMock) GetBuildings(ctx context.Context) (b1 models.BuildingSlice, err error) {
	mm_atomic.AddUint64(&mmGetBuildings.beforeGetBuildingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBuildings.afterGetBuildingsCounter, 1)

	if mmGetBuildings.inspectFuncGetBuildings != nil {
		mmGetBuildings.inspectFuncGetBuildings(ctx)
	}

	mm_params := BuildingsServiceMockGetBuildingsParams{ctx}

	// Record call args
	mmGetBuildings.GetBuildingsMock.mutex.Lock()
	mmGetBuildings.GetBuildingsMock.callArgs = append(mmGetBuildings.GetBuildingsMock.callArgs, &mm_params)
	mmGetBuildings.GetBuildingsMock.mutex.Unlock()

	for _, e := range mmGetBuildings.GetBuildingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmGetBuildings.GetBuildingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBuildings.GetBuildingsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBuildings.GetBuildingsMock.defaultExpectation.params
		mm_want_ptrs := mmGetBuildings.GetBuildingsMock.defaultExpectation.paramPtrs

		mm_got := BuildingsServiceMockGetBuildingsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBuildings.t.Errorf("BuildingsServiceMock.GetBuildings got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBuildings.t.Errorf("BuildingsServiceMock.GetBuildings got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBuildings.GetBuildingsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBuildings.t.Fatal("No results are set for the BuildingsServiceMock.GetBuildings")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmGetBuildings.funcGetBuildings != nil {
		return mmGetBuildings.funcGetBuildings(ctx)
	}
	mmGetBuildings.t.Fatalf("Unexpected call to BuildingsServiceMock.GetBuildings. %v", ctx)
	return
}

// GetBuildingsAfterCounter returns a count of finished BuildingsServiceMock.GetBuildings invocations
func (mmGetBuildings *BuildingsServiceMock) GetBuildingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuildings.afterGetBuildingsCounter)
}

// GetBuildingsBeforeCounter returns a count of BuildingsServiceMock.GetBuildings invocations
func (mmGetBuildings *BuildingsServiceMock) GetBuildingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuildings.beforeGetBuildingsCounter)
}

// Calls returns a list of arguments used in each call to BuildingsServiceMock.GetBuildings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBuildings *mBuildingsServiceMockGetBuildings) Calls() []*BuildingsServiceMockGetBuildingsParams {
	mmGetBuildings.mutex.RLock()

	argCopy := make([]*BuildingsServiceMockGetBuildingsParams, len(mmGetBuildings.callArgs))
	copy(argCopy, mmGetBuildings.callArgs)

	mmGetBuildings.mutex.RUnlock()

	return argCopy
}

// MinimockGetBuildingsDone returns true if the count of the GetBuildings invocations corresponds
// the number of defined expectations
func (m *BuildingsServiceMock) MinimockGetBuildingsDone() bool {
	if m.GetBuildingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBuildingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBuildingsMock.invocationsDone()
}

// MinimockGetBuildingsInspect logs each unmet expectation
func (m *BuildingsServiceMock) MinimockGetBuildingsInspect() {
	for _, e := range m.GetBuildingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsServiceMock.GetBuildings with params: %#v", *e.params)
		}
	}

	afterGetBuildingsCounter := mm_atomic.LoadUint64(&m.afterGetBuildingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBuildingsMock.defaultExpectation != nil && afterGetBuildingsCounter < 1 {
		if m.GetBuildingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsServiceMock.GetBuildings")
		} else {
			m.t.Errorf("Expected call to BuildingsServiceMock.GetBuildings with params: %#v", *m.GetBuildingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBuildings != nil && afterGetBuildingsCounter < 1 {
		m.t.Error("Expected call to BuildingsServiceMock.GetBuildings")
	}

	if !m.GetBuildingsMock.invocationsDone() && afterGetBuildingsCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsServiceMock.GetBuildings but found %d calls",
			mm_atomic.LoadUint64(&m.GetBuildingsMock.expectedInvocations), afterGetBuildingsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BuildingsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateBuildingInspect()

			m.MinimockDeleteBuildingInspect()

			m.MinimockGetBuildingInspect()

			m.MinimockGetBuildingsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BuildingsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BuildingsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBuildingDone() &&
		m.MinimockDeleteBuildingDone() &&
		m.MinimockGetBuildingDone() &&
		m.MinimockGetBuildingsDone()
}
