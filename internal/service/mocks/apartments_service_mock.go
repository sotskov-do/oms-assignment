// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sotskov-do/oms-assignment/internal/service/apartments.ApartmentsService -o apartments_service_mock_test.go -n ApartmentsServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sotskov-do/oms-assignment/internal/models"
)

// ApartmentsServiceMock implements apartments.ApartmentsService
type ApartmentsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateApartment          func(ctx context.Context, apartment *models.Apartment) (err error)
	inspectFuncCreateApartment   func(ctx context.Context, apartment *models.Apartment)
	afterCreateApartmentCounter  uint64
	beforeCreateApartmentCounter uint64
	CreateApartmentMock          mApartmentsServiceMockCreateApartment

	funcDeleteApartment          func(ctx context.Context, id int) (err error)
	inspectFuncDeleteApartment   func(ctx context.Context, id int)
	afterDeleteApartmentCounter  uint64
	beforeDeleteApartmentCounter uint64
	DeleteApartmentMock          mApartmentsServiceMockDeleteApartment

	funcGetApartment          func(ctx context.Context, id int) (ap1 *models.Apartment, err error)
	inspectFuncGetApartment   func(ctx context.Context, id int)
	afterGetApartmentCounter  uint64
	beforeGetApartmentCounter uint64
	GetApartmentMock          mApartmentsServiceMockGetApartment

	funcGetApartments          func(ctx context.Context) (a1 models.ApartmentSlice, err error)
	inspectFuncGetApartments   func(ctx context.Context)
	afterGetApartmentsCounter  uint64
	beforeGetApartmentsCounter uint64
	GetApartmentsMock          mApartmentsServiceMockGetApartments

	funcGetApartmentsInBuilding          func(ctx context.Context, buildingId int) (a1 models.ApartmentSlice, err error)
	inspectFuncGetApartmentsInBuilding   func(ctx context.Context, buildingId int)
	afterGetApartmentsInBuildingCounter  uint64
	beforeGetApartmentsInBuildingCounter uint64
	GetApartmentsInBuildingMock          mApartmentsServiceMockGetApartmentsInBuilding
}

// NewApartmentsServiceMock returns a mock for apartments.ApartmentsService
func NewApartmentsServiceMock(t minimock.Tester) *ApartmentsServiceMock {
	m := &ApartmentsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateApartmentMock = mApartmentsServiceMockCreateApartment{mock: m}
	m.CreateApartmentMock.callArgs = []*ApartmentsServiceMockCreateApartmentParams{}

	m.DeleteApartmentMock = mApartmentsServiceMockDeleteApartment{mock: m}
	m.DeleteApartmentMock.callArgs = []*ApartmentsServiceMockDeleteApartmentParams{}

	m.GetApartmentMock = mApartmentsServiceMockGetApartment{mock: m}
	m.GetApartmentMock.callArgs = []*ApartmentsServiceMockGetApartmentParams{}

	m.GetApartmentsMock = mApartmentsServiceMockGetApartments{mock: m}
	m.GetApartmentsMock.callArgs = []*ApartmentsServiceMockGetApartmentsParams{}

	m.GetApartmentsInBuildingMock = mApartmentsServiceMockGetApartmentsInBuilding{mock: m}
	m.GetApartmentsInBuildingMock.callArgs = []*ApartmentsServiceMockGetApartmentsInBuildingParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mApartmentsServiceMockCreateApartment struct {
	optional           bool
	mock               *ApartmentsServiceMock
	defaultExpectation *ApartmentsServiceMockCreateApartmentExpectation
	expectations       []*ApartmentsServiceMockCreateApartmentExpectation

	callArgs []*ApartmentsServiceMockCreateApartmentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsServiceMockCreateApartmentExpectation specifies expectation struct of the ApartmentsService.CreateApartment
type ApartmentsServiceMockCreateApartmentExpectation struct {
	mock      *ApartmentsServiceMock
	params    *ApartmentsServiceMockCreateApartmentParams
	paramPtrs *ApartmentsServiceMockCreateApartmentParamPtrs
	results   *ApartmentsServiceMockCreateApartmentResults
	Counter   uint64
}

// ApartmentsServiceMockCreateApartmentParams contains parameters of the ApartmentsService.CreateApartment
type ApartmentsServiceMockCreateApartmentParams struct {
	ctx       context.Context
	apartment *models.Apartment
}

// ApartmentsServiceMockCreateApartmentParamPtrs contains pointers to parameters of the ApartmentsService.CreateApartment
type ApartmentsServiceMockCreateApartmentParamPtrs struct {
	ctx       *context.Context
	apartment **models.Apartment
}

// ApartmentsServiceMockCreateApartmentResults contains results of the ApartmentsService.CreateApartment
type ApartmentsServiceMockCreateApartmentResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Optional() *mApartmentsServiceMockCreateApartment {
	mmCreateApartment.optional = true
	return mmCreateApartment
}

// Expect sets up expected params for ApartmentsService.CreateApartment
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Expect(ctx context.Context, apartment *models.Apartment) *mApartmentsServiceMockCreateApartment {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsServiceMockCreateApartmentExpectation{}
	}

	if mmCreateApartment.defaultExpectation.paramPtrs != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by ExpectParams functions")
	}

	mmCreateApartment.defaultExpectation.params = &ApartmentsServiceMockCreateApartmentParams{ctx, apartment}
	for _, e := range mmCreateApartment.expectations {
		if minimock.Equal(e.params, mmCreateApartment.defaultExpectation.params) {
			mmCreateApartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateApartment.defaultExpectation.params)
		}
	}

	return mmCreateApartment
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsService.CreateApartment
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) ExpectCtxParam1(ctx context.Context) *mApartmentsServiceMockCreateApartment {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsServiceMockCreateApartmentExpectation{}
	}

	if mmCreateApartment.defaultExpectation.params != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Expect")
	}

	if mmCreateApartment.defaultExpectation.paramPtrs == nil {
		mmCreateApartment.defaultExpectation.paramPtrs = &ApartmentsServiceMockCreateApartmentParamPtrs{}
	}
	mmCreateApartment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateApartment
}

// ExpectApartmentParam2 sets up expected param apartment for ApartmentsService.CreateApartment
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) ExpectApartmentParam2(apartment *models.Apartment) *mApartmentsServiceMockCreateApartment {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsServiceMockCreateApartmentExpectation{}
	}

	if mmCreateApartment.defaultExpectation.params != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Expect")
	}

	if mmCreateApartment.defaultExpectation.paramPtrs == nil {
		mmCreateApartment.defaultExpectation.paramPtrs = &ApartmentsServiceMockCreateApartmentParamPtrs{}
	}
	mmCreateApartment.defaultExpectation.paramPtrs.apartment = &apartment

	return mmCreateApartment
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsService.CreateApartment
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Inspect(f func(ctx context.Context, apartment *models.Apartment)) *mApartmentsServiceMockCreateApartment {
	if mmCreateApartment.mock.inspectFuncCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("Inspect function is already set for ApartmentsServiceMock.CreateApartment")
	}

	mmCreateApartment.mock.inspectFuncCreateApartment = f

	return mmCreateApartment
}

// Return sets up results that will be returned by ApartmentsService.CreateApartment
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Return(err error) *ApartmentsServiceMock {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsServiceMockCreateApartmentExpectation{mock: mmCreateApartment.mock}
	}
	mmCreateApartment.defaultExpectation.results = &ApartmentsServiceMockCreateApartmentResults{err}
	return mmCreateApartment.mock
}

// Set uses given function f to mock the ApartmentsService.CreateApartment method
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Set(f func(ctx context.Context, apartment *models.Apartment) (err error)) *ApartmentsServiceMock {
	if mmCreateApartment.defaultExpectation != nil {
		mmCreateApartment.mock.t.Fatalf("Default expectation is already set for the ApartmentsService.CreateApartment method")
	}

	if len(mmCreateApartment.expectations) > 0 {
		mmCreateApartment.mock.t.Fatalf("Some expectations are already set for the ApartmentsService.CreateApartment method")
	}

	mmCreateApartment.mock.funcCreateApartment = f
	return mmCreateApartment.mock
}

// When sets expectation for the ApartmentsService.CreateApartment which will trigger the result defined by the following
// Then helper
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) When(ctx context.Context, apartment *models.Apartment) *ApartmentsServiceMockCreateApartmentExpectation {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsServiceMock.CreateApartment mock is already set by Set")
	}

	expectation := &ApartmentsServiceMockCreateApartmentExpectation{
		mock:   mmCreateApartment.mock,
		params: &ApartmentsServiceMockCreateApartmentParams{ctx, apartment},
	}
	mmCreateApartment.expectations = append(mmCreateApartment.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsService.CreateApartment return parameters for the expectation previously defined by the When method
func (e *ApartmentsServiceMockCreateApartmentExpectation) Then(err error) *ApartmentsServiceMock {
	e.results = &ApartmentsServiceMockCreateApartmentResults{err}
	return e.mock
}

// Times sets number of times ApartmentsService.CreateApartment should be invoked
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Times(n uint64) *mApartmentsServiceMockCreateApartment {
	if n == 0 {
		mmCreateApartment.mock.t.Fatalf("Times of ApartmentsServiceMock.CreateApartment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateApartment.expectedInvocations, n)
	return mmCreateApartment
}

func (mmCreateApartment *mApartmentsServiceMockCreateApartment) invocationsDone() bool {
	if len(mmCreateApartment.expectations) == 0 && mmCreateApartment.defaultExpectation == nil && mmCreateApartment.mock.funcCreateApartment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateApartment.mock.afterCreateApartmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateApartment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateApartment implements apartments.ApartmentsService
func (mmCreateApartment *ApartmentsServiceMock) CreateApartment(ctx context.Context, apartment *models.Apartment) (err error) {
	mm_atomic.AddUint64(&mmCreateApartment.beforeCreateApartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateApartment.afterCreateApartmentCounter, 1)

	if mmCreateApartment.inspectFuncCreateApartment != nil {
		mmCreateApartment.inspectFuncCreateApartment(ctx, apartment)
	}

	mm_params := ApartmentsServiceMockCreateApartmentParams{ctx, apartment}

	// Record call args
	mmCreateApartment.CreateApartmentMock.mutex.Lock()
	mmCreateApartment.CreateApartmentMock.callArgs = append(mmCreateApartment.CreateApartmentMock.callArgs, &mm_params)
	mmCreateApartment.CreateApartmentMock.mutex.Unlock()

	for _, e := range mmCreateApartment.CreateApartmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateApartment.CreateApartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateApartment.CreateApartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateApartment.CreateApartmentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateApartment.CreateApartmentMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsServiceMockCreateApartmentParams{ctx, apartment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateApartment.t.Errorf("ApartmentsServiceMock.CreateApartment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.apartment != nil && !minimock.Equal(*mm_want_ptrs.apartment, mm_got.apartment) {
				mmCreateApartment.t.Errorf("ApartmentsServiceMock.CreateApartment got unexpected parameter apartment, want: %#v, got: %#v%s\n", *mm_want_ptrs.apartment, mm_got.apartment, minimock.Diff(*mm_want_ptrs.apartment, mm_got.apartment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateApartment.t.Errorf("ApartmentsServiceMock.CreateApartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateApartment.CreateApartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateApartment.t.Fatal("No results are set for the ApartmentsServiceMock.CreateApartment")
		}
		return (*mm_results).err
	}
	if mmCreateApartment.funcCreateApartment != nil {
		return mmCreateApartment.funcCreateApartment(ctx, apartment)
	}
	mmCreateApartment.t.Fatalf("Unexpected call to ApartmentsServiceMock.CreateApartment. %v %v", ctx, apartment)
	return
}

// CreateApartmentAfterCounter returns a count of finished ApartmentsServiceMock.CreateApartment invocations
func (mmCreateApartment *ApartmentsServiceMock) CreateApartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApartment.afterCreateApartmentCounter)
}

// CreateApartmentBeforeCounter returns a count of ApartmentsServiceMock.CreateApartment invocations
func (mmCreateApartment *ApartmentsServiceMock) CreateApartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApartment.beforeCreateApartmentCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsServiceMock.CreateApartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateApartment *mApartmentsServiceMockCreateApartment) Calls() []*ApartmentsServiceMockCreateApartmentParams {
	mmCreateApartment.mutex.RLock()

	argCopy := make([]*ApartmentsServiceMockCreateApartmentParams, len(mmCreateApartment.callArgs))
	copy(argCopy, mmCreateApartment.callArgs)

	mmCreateApartment.mutex.RUnlock()

	return argCopy
}

// MinimockCreateApartmentDone returns true if the count of the CreateApartment invocations corresponds
// the number of defined expectations
func (m *ApartmentsServiceMock) MinimockCreateApartmentDone() bool {
	if m.CreateApartmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateApartmentMock.invocationsDone()
}

// MinimockCreateApartmentInspect logs each unmet expectation
func (m *ApartmentsServiceMock) MinimockCreateApartmentInspect() {
	for _, e := range m.CreateApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsServiceMock.CreateApartment with params: %#v", *e.params)
		}
	}

	afterCreateApartmentCounter := mm_atomic.LoadUint64(&m.afterCreateApartmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateApartmentMock.defaultExpectation != nil && afterCreateApartmentCounter < 1 {
		if m.CreateApartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsServiceMock.CreateApartment")
		} else {
			m.t.Errorf("Expected call to ApartmentsServiceMock.CreateApartment with params: %#v", *m.CreateApartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateApartment != nil && afterCreateApartmentCounter < 1 {
		m.t.Error("Expected call to ApartmentsServiceMock.CreateApartment")
	}

	if !m.CreateApartmentMock.invocationsDone() && afterCreateApartmentCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsServiceMock.CreateApartment but found %d calls",
			mm_atomic.LoadUint64(&m.CreateApartmentMock.expectedInvocations), afterCreateApartmentCounter)
	}
}

type mApartmentsServiceMockDeleteApartment struct {
	optional           bool
	mock               *ApartmentsServiceMock
	defaultExpectation *ApartmentsServiceMockDeleteApartmentExpectation
	expectations       []*ApartmentsServiceMockDeleteApartmentExpectation

	callArgs []*ApartmentsServiceMockDeleteApartmentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsServiceMockDeleteApartmentExpectation specifies expectation struct of the ApartmentsService.DeleteApartment
type ApartmentsServiceMockDeleteApartmentExpectation struct {
	mock      *ApartmentsServiceMock
	params    *ApartmentsServiceMockDeleteApartmentParams
	paramPtrs *ApartmentsServiceMockDeleteApartmentParamPtrs
	results   *ApartmentsServiceMockDeleteApartmentResults
	Counter   uint64
}

// ApartmentsServiceMockDeleteApartmentParams contains parameters of the ApartmentsService.DeleteApartment
type ApartmentsServiceMockDeleteApartmentParams struct {
	ctx context.Context
	id  int
}

// ApartmentsServiceMockDeleteApartmentParamPtrs contains pointers to parameters of the ApartmentsService.DeleteApartment
type ApartmentsServiceMockDeleteApartmentParamPtrs struct {
	ctx *context.Context
	id  *int
}

// ApartmentsServiceMockDeleteApartmentResults contains results of the ApartmentsService.DeleteApartment
type ApartmentsServiceMockDeleteApartmentResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Optional() *mApartmentsServiceMockDeleteApartment {
	mmDeleteApartment.optional = true
	return mmDeleteApartment
}

// Expect sets up expected params for ApartmentsService.DeleteApartment
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Expect(ctx context.Context, id int) *mApartmentsServiceMockDeleteApartment {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsServiceMockDeleteApartmentExpectation{}
	}

	if mmDeleteApartment.defaultExpectation.paramPtrs != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by ExpectParams functions")
	}

	mmDeleteApartment.defaultExpectation.params = &ApartmentsServiceMockDeleteApartmentParams{ctx, id}
	for _, e := range mmDeleteApartment.expectations {
		if minimock.Equal(e.params, mmDeleteApartment.defaultExpectation.params) {
			mmDeleteApartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteApartment.defaultExpectation.params)
		}
	}

	return mmDeleteApartment
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsService.DeleteApartment
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) ExpectCtxParam1(ctx context.Context) *mApartmentsServiceMockDeleteApartment {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsServiceMockDeleteApartmentExpectation{}
	}

	if mmDeleteApartment.defaultExpectation.params != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Expect")
	}

	if mmDeleteApartment.defaultExpectation.paramPtrs == nil {
		mmDeleteApartment.defaultExpectation.paramPtrs = &ApartmentsServiceMockDeleteApartmentParamPtrs{}
	}
	mmDeleteApartment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteApartment
}

// ExpectIdParam2 sets up expected param id for ApartmentsService.DeleteApartment
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) ExpectIdParam2(id int) *mApartmentsServiceMockDeleteApartment {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsServiceMockDeleteApartmentExpectation{}
	}

	if mmDeleteApartment.defaultExpectation.params != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Expect")
	}

	if mmDeleteApartment.defaultExpectation.paramPtrs == nil {
		mmDeleteApartment.defaultExpectation.paramPtrs = &ApartmentsServiceMockDeleteApartmentParamPtrs{}
	}
	mmDeleteApartment.defaultExpectation.paramPtrs.id = &id

	return mmDeleteApartment
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsService.DeleteApartment
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Inspect(f func(ctx context.Context, id int)) *mApartmentsServiceMockDeleteApartment {
	if mmDeleteApartment.mock.inspectFuncDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("Inspect function is already set for ApartmentsServiceMock.DeleteApartment")
	}

	mmDeleteApartment.mock.inspectFuncDeleteApartment = f

	return mmDeleteApartment
}

// Return sets up results that will be returned by ApartmentsService.DeleteApartment
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Return(err error) *ApartmentsServiceMock {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsServiceMockDeleteApartmentExpectation{mock: mmDeleteApartment.mock}
	}
	mmDeleteApartment.defaultExpectation.results = &ApartmentsServiceMockDeleteApartmentResults{err}
	return mmDeleteApartment.mock
}

// Set uses given function f to mock the ApartmentsService.DeleteApartment method
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Set(f func(ctx context.Context, id int) (err error)) *ApartmentsServiceMock {
	if mmDeleteApartment.defaultExpectation != nil {
		mmDeleteApartment.mock.t.Fatalf("Default expectation is already set for the ApartmentsService.DeleteApartment method")
	}

	if len(mmDeleteApartment.expectations) > 0 {
		mmDeleteApartment.mock.t.Fatalf("Some expectations are already set for the ApartmentsService.DeleteApartment method")
	}

	mmDeleteApartment.mock.funcDeleteApartment = f
	return mmDeleteApartment.mock
}

// When sets expectation for the ApartmentsService.DeleteApartment which will trigger the result defined by the following
// Then helper
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) When(ctx context.Context, id int) *ApartmentsServiceMockDeleteApartmentExpectation {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsServiceMock.DeleteApartment mock is already set by Set")
	}

	expectation := &ApartmentsServiceMockDeleteApartmentExpectation{
		mock:   mmDeleteApartment.mock,
		params: &ApartmentsServiceMockDeleteApartmentParams{ctx, id},
	}
	mmDeleteApartment.expectations = append(mmDeleteApartment.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsService.DeleteApartment return parameters for the expectation previously defined by the When method
func (e *ApartmentsServiceMockDeleteApartmentExpectation) Then(err error) *ApartmentsServiceMock {
	e.results = &ApartmentsServiceMockDeleteApartmentResults{err}
	return e.mock
}

// Times sets number of times ApartmentsService.DeleteApartment should be invoked
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Times(n uint64) *mApartmentsServiceMockDeleteApartment {
	if n == 0 {
		mmDeleteApartment.mock.t.Fatalf("Times of ApartmentsServiceMock.DeleteApartment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteApartment.expectedInvocations, n)
	return mmDeleteApartment
}

func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) invocationsDone() bool {
	if len(mmDeleteApartment.expectations) == 0 && mmDeleteApartment.defaultExpectation == nil && mmDeleteApartment.mock.funcDeleteApartment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteApartment.mock.afterDeleteApartmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteApartment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteApartment implements apartments.ApartmentsService
func (mmDeleteApartment *ApartmentsServiceMock) DeleteApartment(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteApartment.beforeDeleteApartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteApartment.afterDeleteApartmentCounter, 1)

	if mmDeleteApartment.inspectFuncDeleteApartment != nil {
		mmDeleteApartment.inspectFuncDeleteApartment(ctx, id)
	}

	mm_params := ApartmentsServiceMockDeleteApartmentParams{ctx, id}

	// Record call args
	mmDeleteApartment.DeleteApartmentMock.mutex.Lock()
	mmDeleteApartment.DeleteApartmentMock.callArgs = append(mmDeleteApartment.DeleteApartmentMock.callArgs, &mm_params)
	mmDeleteApartment.DeleteApartmentMock.mutex.Unlock()

	for _, e := range mmDeleteApartment.DeleteApartmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteApartment.DeleteApartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteApartment.DeleteApartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteApartment.DeleteApartmentMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteApartment.DeleteApartmentMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsServiceMockDeleteApartmentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteApartment.t.Errorf("ApartmentsServiceMock.DeleteApartment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteApartment.t.Errorf("ApartmentsServiceMock.DeleteApartment got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteApartment.t.Errorf("ApartmentsServiceMock.DeleteApartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteApartment.DeleteApartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteApartment.t.Fatal("No results are set for the ApartmentsServiceMock.DeleteApartment")
		}
		return (*mm_results).err
	}
	if mmDeleteApartment.funcDeleteApartment != nil {
		return mmDeleteApartment.funcDeleteApartment(ctx, id)
	}
	mmDeleteApartment.t.Fatalf("Unexpected call to ApartmentsServiceMock.DeleteApartment. %v %v", ctx, id)
	return
}

// DeleteApartmentAfterCounter returns a count of finished ApartmentsServiceMock.DeleteApartment invocations
func (mmDeleteApartment *ApartmentsServiceMock) DeleteApartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApartment.afterDeleteApartmentCounter)
}

// DeleteApartmentBeforeCounter returns a count of ApartmentsServiceMock.DeleteApartment invocations
func (mmDeleteApartment *ApartmentsServiceMock) DeleteApartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApartment.beforeDeleteApartmentCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsServiceMock.DeleteApartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteApartment *mApartmentsServiceMockDeleteApartment) Calls() []*ApartmentsServiceMockDeleteApartmentParams {
	mmDeleteApartment.mutex.RLock()

	argCopy := make([]*ApartmentsServiceMockDeleteApartmentParams, len(mmDeleteApartment.callArgs))
	copy(argCopy, mmDeleteApartment.callArgs)

	mmDeleteApartment.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteApartmentDone returns true if the count of the DeleteApartment invocations corresponds
// the number of defined expectations
func (m *ApartmentsServiceMock) MinimockDeleteApartmentDone() bool {
	if m.DeleteApartmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteApartmentMock.invocationsDone()
}

// MinimockDeleteApartmentInspect logs each unmet expectation
func (m *ApartmentsServiceMock) MinimockDeleteApartmentInspect() {
	for _, e := range m.DeleteApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsServiceMock.DeleteApartment with params: %#v", *e.params)
		}
	}

	afterDeleteApartmentCounter := mm_atomic.LoadUint64(&m.afterDeleteApartmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteApartmentMock.defaultExpectation != nil && afterDeleteApartmentCounter < 1 {
		if m.DeleteApartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsServiceMock.DeleteApartment")
		} else {
			m.t.Errorf("Expected call to ApartmentsServiceMock.DeleteApartment with params: %#v", *m.DeleteApartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteApartment != nil && afterDeleteApartmentCounter < 1 {
		m.t.Error("Expected call to ApartmentsServiceMock.DeleteApartment")
	}

	if !m.DeleteApartmentMock.invocationsDone() && afterDeleteApartmentCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsServiceMock.DeleteApartment but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteApartmentMock.expectedInvocations), afterDeleteApartmentCounter)
	}
}

type mApartmentsServiceMockGetApartment struct {
	optional           bool
	mock               *ApartmentsServiceMock
	defaultExpectation *ApartmentsServiceMockGetApartmentExpectation
	expectations       []*ApartmentsServiceMockGetApartmentExpectation

	callArgs []*ApartmentsServiceMockGetApartmentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsServiceMockGetApartmentExpectation specifies expectation struct of the ApartmentsService.GetApartment
type ApartmentsServiceMockGetApartmentExpectation struct {
	mock      *ApartmentsServiceMock
	params    *ApartmentsServiceMockGetApartmentParams
	paramPtrs *ApartmentsServiceMockGetApartmentParamPtrs
	results   *ApartmentsServiceMockGetApartmentResults
	Counter   uint64
}

// ApartmentsServiceMockGetApartmentParams contains parameters of the ApartmentsService.GetApartment
type ApartmentsServiceMockGetApartmentParams struct {
	ctx context.Context
	id  int
}

// ApartmentsServiceMockGetApartmentParamPtrs contains pointers to parameters of the ApartmentsService.GetApartment
type ApartmentsServiceMockGetApartmentParamPtrs struct {
	ctx *context.Context
	id  *int
}

// ApartmentsServiceMockGetApartmentResults contains results of the ApartmentsService.GetApartment
type ApartmentsServiceMockGetApartmentResults struct {
	ap1 *models.Apartment
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApartment *mApartmentsServiceMockGetApartment) Optional() *mApartmentsServiceMockGetApartment {
	mmGetApartment.optional = true
	return mmGetApartment
}

// Expect sets up expected params for ApartmentsService.GetApartment
func (mmGetApartment *mApartmentsServiceMockGetApartment) Expect(ctx context.Context, id int) *mApartmentsServiceMockGetApartment {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsServiceMockGetApartmentExpectation{}
	}

	if mmGetApartment.defaultExpectation.paramPtrs != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by ExpectParams functions")
	}

	mmGetApartment.defaultExpectation.params = &ApartmentsServiceMockGetApartmentParams{ctx, id}
	for _, e := range mmGetApartment.expectations {
		if minimock.Equal(e.params, mmGetApartment.defaultExpectation.params) {
			mmGetApartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApartment.defaultExpectation.params)
		}
	}

	return mmGetApartment
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsService.GetApartment
func (mmGetApartment *mApartmentsServiceMockGetApartment) ExpectCtxParam1(ctx context.Context) *mApartmentsServiceMockGetApartment {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsServiceMockGetApartmentExpectation{}
	}

	if mmGetApartment.defaultExpectation.params != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Expect")
	}

	if mmGetApartment.defaultExpectation.paramPtrs == nil {
		mmGetApartment.defaultExpectation.paramPtrs = &ApartmentsServiceMockGetApartmentParamPtrs{}
	}
	mmGetApartment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApartment
}

// ExpectIdParam2 sets up expected param id for ApartmentsService.GetApartment
func (mmGetApartment *mApartmentsServiceMockGetApartment) ExpectIdParam2(id int) *mApartmentsServiceMockGetApartment {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsServiceMockGetApartmentExpectation{}
	}

	if mmGetApartment.defaultExpectation.params != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Expect")
	}

	if mmGetApartment.defaultExpectation.paramPtrs == nil {
		mmGetApartment.defaultExpectation.paramPtrs = &ApartmentsServiceMockGetApartmentParamPtrs{}
	}
	mmGetApartment.defaultExpectation.paramPtrs.id = &id

	return mmGetApartment
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsService.GetApartment
func (mmGetApartment *mApartmentsServiceMockGetApartment) Inspect(f func(ctx context.Context, id int)) *mApartmentsServiceMockGetApartment {
	if mmGetApartment.mock.inspectFuncGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("Inspect function is already set for ApartmentsServiceMock.GetApartment")
	}

	mmGetApartment.mock.inspectFuncGetApartment = f

	return mmGetApartment
}

// Return sets up results that will be returned by ApartmentsService.GetApartment
func (mmGetApartment *mApartmentsServiceMockGetApartment) Return(ap1 *models.Apartment, err error) *ApartmentsServiceMock {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsServiceMockGetApartmentExpectation{mock: mmGetApartment.mock}
	}
	mmGetApartment.defaultExpectation.results = &ApartmentsServiceMockGetApartmentResults{ap1, err}
	return mmGetApartment.mock
}

// Set uses given function f to mock the ApartmentsService.GetApartment method
func (mmGetApartment *mApartmentsServiceMockGetApartment) Set(f func(ctx context.Context, id int) (ap1 *models.Apartment, err error)) *ApartmentsServiceMock {
	if mmGetApartment.defaultExpectation != nil {
		mmGetApartment.mock.t.Fatalf("Default expectation is already set for the ApartmentsService.GetApartment method")
	}

	if len(mmGetApartment.expectations) > 0 {
		mmGetApartment.mock.t.Fatalf("Some expectations are already set for the ApartmentsService.GetApartment method")
	}

	mmGetApartment.mock.funcGetApartment = f
	return mmGetApartment.mock
}

// When sets expectation for the ApartmentsService.GetApartment which will trigger the result defined by the following
// Then helper
func (mmGetApartment *mApartmentsServiceMockGetApartment) When(ctx context.Context, id int) *ApartmentsServiceMockGetApartmentExpectation {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsServiceMock.GetApartment mock is already set by Set")
	}

	expectation := &ApartmentsServiceMockGetApartmentExpectation{
		mock:   mmGetApartment.mock,
		params: &ApartmentsServiceMockGetApartmentParams{ctx, id},
	}
	mmGetApartment.expectations = append(mmGetApartment.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsService.GetApartment return parameters for the expectation previously defined by the When method
func (e *ApartmentsServiceMockGetApartmentExpectation) Then(ap1 *models.Apartment, err error) *ApartmentsServiceMock {
	e.results = &ApartmentsServiceMockGetApartmentResults{ap1, err}
	return e.mock
}

// Times sets number of times ApartmentsService.GetApartment should be invoked
func (mmGetApartment *mApartmentsServiceMockGetApartment) Times(n uint64) *mApartmentsServiceMockGetApartment {
	if n == 0 {
		mmGetApartment.mock.t.Fatalf("Times of ApartmentsServiceMock.GetApartment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApartment.expectedInvocations, n)
	return mmGetApartment
}

func (mmGetApartment *mApartmentsServiceMockGetApartment) invocationsDone() bool {
	if len(mmGetApartment.expectations) == 0 && mmGetApartment.defaultExpectation == nil && mmGetApartment.mock.funcGetApartment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApartment.mock.afterGetApartmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApartment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApartment implements apartments.ApartmentsService
func (mmGetApartment *ApartmentsServiceMock) GetApartment(ctx context.Context, id int) (ap1 *models.Apartment, err error) {
	mm_atomic.AddUint64(&mmGetApartment.beforeGetApartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApartment.afterGetApartmentCounter, 1)

	if mmGetApartment.inspectFuncGetApartment != nil {
		mmGetApartment.inspectFuncGetApartment(ctx, id)
	}

	mm_params := ApartmentsServiceMockGetApartmentParams{ctx, id}

	// Record call args
	mmGetApartment.GetApartmentMock.mutex.Lock()
	mmGetApartment.GetApartmentMock.callArgs = append(mmGetApartment.GetApartmentMock.callArgs, &mm_params)
	mmGetApartment.GetApartmentMock.mutex.Unlock()

	for _, e := range mmGetApartment.GetApartmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApartment.GetApartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApartment.GetApartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApartment.GetApartmentMock.defaultExpectation.params
		mm_want_ptrs := mmGetApartment.GetApartmentMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsServiceMockGetApartmentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApartment.t.Errorf("ApartmentsServiceMock.GetApartment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetApartment.t.Errorf("ApartmentsServiceMock.GetApartment got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApartment.t.Errorf("ApartmentsServiceMock.GetApartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApartment.GetApartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApartment.t.Fatal("No results are set for the ApartmentsServiceMock.GetApartment")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApartment.funcGetApartment != nil {
		return mmGetApartment.funcGetApartment(ctx, id)
	}
	mmGetApartment.t.Fatalf("Unexpected call to ApartmentsServiceMock.GetApartment. %v %v", ctx, id)
	return
}

// GetApartmentAfterCounter returns a count of finished ApartmentsServiceMock.GetApartment invocations
func (mmGetApartment *ApartmentsServiceMock) GetApartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartment.afterGetApartmentCounter)
}

// GetApartmentBeforeCounter returns a count of ApartmentsServiceMock.GetApartment invocations
func (mmGetApartment *ApartmentsServiceMock) GetApartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartment.beforeGetApartmentCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsServiceMock.GetApartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApartment *mApartmentsServiceMockGetApartment) Calls() []*ApartmentsServiceMockGetApartmentParams {
	mmGetApartment.mutex.RLock()

	argCopy := make([]*ApartmentsServiceMockGetApartmentParams, len(mmGetApartment.callArgs))
	copy(argCopy, mmGetApartment.callArgs)

	mmGetApartment.mutex.RUnlock()

	return argCopy
}

// MinimockGetApartmentDone returns true if the count of the GetApartment invocations corresponds
// the number of defined expectations
func (m *ApartmentsServiceMock) MinimockGetApartmentDone() bool {
	if m.GetApartmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApartmentMock.invocationsDone()
}

// MinimockGetApartmentInspect logs each unmet expectation
func (m *ApartmentsServiceMock) MinimockGetApartmentInspect() {
	for _, e := range m.GetApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsServiceMock.GetApartment with params: %#v", *e.params)
		}
	}

	afterGetApartmentCounter := mm_atomic.LoadUint64(&m.afterGetApartmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApartmentMock.defaultExpectation != nil && afterGetApartmentCounter < 1 {
		if m.GetApartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsServiceMock.GetApartment")
		} else {
			m.t.Errorf("Expected call to ApartmentsServiceMock.GetApartment with params: %#v", *m.GetApartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApartment != nil && afterGetApartmentCounter < 1 {
		m.t.Error("Expected call to ApartmentsServiceMock.GetApartment")
	}

	if !m.GetApartmentMock.invocationsDone() && afterGetApartmentCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsServiceMock.GetApartment but found %d calls",
			mm_atomic.LoadUint64(&m.GetApartmentMock.expectedInvocations), afterGetApartmentCounter)
	}
}

type mApartmentsServiceMockGetApartments struct {
	optional           bool
	mock               *ApartmentsServiceMock
	defaultExpectation *ApartmentsServiceMockGetApartmentsExpectation
	expectations       []*ApartmentsServiceMockGetApartmentsExpectation

	callArgs []*ApartmentsServiceMockGetApartmentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsServiceMockGetApartmentsExpectation specifies expectation struct of the ApartmentsService.GetApartments
type ApartmentsServiceMockGetApartmentsExpectation struct {
	mock      *ApartmentsServiceMock
	params    *ApartmentsServiceMockGetApartmentsParams
	paramPtrs *ApartmentsServiceMockGetApartmentsParamPtrs
	results   *ApartmentsServiceMockGetApartmentsResults
	Counter   uint64
}

// ApartmentsServiceMockGetApartmentsParams contains parameters of the ApartmentsService.GetApartments
type ApartmentsServiceMockGetApartmentsParams struct {
	ctx context.Context
}

// ApartmentsServiceMockGetApartmentsParamPtrs contains pointers to parameters of the ApartmentsService.GetApartments
type ApartmentsServiceMockGetApartmentsParamPtrs struct {
	ctx *context.Context
}

// ApartmentsServiceMockGetApartmentsResults contains results of the ApartmentsService.GetApartments
type ApartmentsServiceMockGetApartmentsResults struct {
	a1  models.ApartmentSlice
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApartments *mApartmentsServiceMockGetApartments) Optional() *mApartmentsServiceMockGetApartments {
	mmGetApartments.optional = true
	return mmGetApartments
}

// Expect sets up expected params for ApartmentsService.GetApartments
func (mmGetApartments *mApartmentsServiceMockGetApartments) Expect(ctx context.Context) *mApartmentsServiceMockGetApartments {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsServiceMock.GetApartments mock is already set by Set")
	}

	if mmGetApartments.defaultExpectation == nil {
		mmGetApartments.defaultExpectation = &ApartmentsServiceMockGetApartmentsExpectation{}
	}

	if mmGetApartments.defaultExpectation.paramPtrs != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsServiceMock.GetApartments mock is already set by ExpectParams functions")
	}

	mmGetApartments.defaultExpectation.params = &ApartmentsServiceMockGetApartmentsParams{ctx}
	for _, e := range mmGetApartments.expectations {
		if minimock.Equal(e.params, mmGetApartments.defaultExpectation.params) {
			mmGetApartments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApartments.defaultExpectation.params)
		}
	}

	return mmGetApartments
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsService.GetApartments
func (mmGetApartments *mApartmentsServiceMockGetApartments) ExpectCtxParam1(ctx context.Context) *mApartmentsServiceMockGetApartments {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsServiceMock.GetApartments mock is already set by Set")
	}

	if mmGetApartments.defaultExpectation == nil {
		mmGetApartments.defaultExpectation = &ApartmentsServiceMockGetApartmentsExpectation{}
	}

	if mmGetApartments.defaultExpectation.params != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsServiceMock.GetApartments mock is already set by Expect")
	}

	if mmGetApartments.defaultExpectation.paramPtrs == nil {
		mmGetApartments.defaultExpectation.paramPtrs = &ApartmentsServiceMockGetApartmentsParamPtrs{}
	}
	mmGetApartments.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApartments
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsService.GetApartments
func (mmGetApartments *mApartmentsServiceMockGetApartments) Inspect(f func(ctx context.Context)) *mApartmentsServiceMockGetApartments {
	if mmGetApartments.mock.inspectFuncGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("Inspect function is already set for ApartmentsServiceMock.GetApartments")
	}

	mmGetApartments.mock.inspectFuncGetApartments = f

	return mmGetApartments
}

// Return sets up results that will be returned by ApartmentsService.GetApartments
func (mmGetApartments *mApartmentsServiceMockGetApartments) Return(a1 models.ApartmentSlice, err error) *ApartmentsServiceMock {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsServiceMock.GetApartments mock is already set by Set")
	}

	if mmGetApartments.defaultExpectation == nil {
		mmGetApartments.defaultExpectation = &ApartmentsServiceMockGetApartmentsExpectation{mock: mmGetApartments.mock}
	}
	mmGetApartments.defaultExpectation.results = &ApartmentsServiceMockGetApartmentsResults{a1, err}
	return mmGetApartments.mock
}

// Set uses given function f to mock the ApartmentsService.GetApartments method
func (mmGetApartments *mApartmentsServiceMockGetApartments) Set(f func(ctx context.Context) (a1 models.ApartmentSlice, err error)) *ApartmentsServiceMock {
	if mmGetApartments.defaultExpectation != nil {
		mmGetApartments.mock.t.Fatalf("Default expectation is already set for the ApartmentsService.GetApartments method")
	}

	if len(mmGetApartments.expectations) > 0 {
		mmGetApartments.mock.t.Fatalf("Some expectations are already set for the ApartmentsService.GetApartments method")
	}

	mmGetApartments.mock.funcGetApartments = f
	return mmGetApartments.mock
}

// When sets expectation for the ApartmentsService.GetApartments which will trigger the result defined by the following
// Then helper
func (mmGetApartments *mApartmentsServiceMockGetApartments) When(ctx context.Context) *ApartmentsServiceMockGetApartmentsExpectation {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsServiceMock.GetApartments mock is already set by Set")
	}

	expectation := &ApartmentsServiceMockGetApartmentsExpectation{
		mock:   mmGetApartments.mock,
		params: &ApartmentsServiceMockGetApartmentsParams{ctx},
	}
	mmGetApartments.expectations = append(mmGetApartments.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsService.GetApartments return parameters for the expectation previously defined by the When method
func (e *ApartmentsServiceMockGetApartmentsExpectation) Then(a1 models.ApartmentSlice, err error) *ApartmentsServiceMock {
	e.results = &ApartmentsServiceMockGetApartmentsResults{a1, err}
	return e.mock
}

// Times sets number of times ApartmentsService.GetApartments should be invoked
func (mmGetApartments *mApartmentsServiceMockGetApartments) Times(n uint64) *mApartmentsServiceMockGetApartments {
	if n == 0 {
		mmGetApartments.mock.t.Fatalf("Times of ApartmentsServiceMock.GetApartments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApartments.expectedInvocations, n)
	return mmGetApartments
}

func (mmGetApartments *mApartmentsServiceMockGetApartments) invocationsDone() bool {
	if len(mmGetApartments.expectations) == 0 && mmGetApartments.defaultExpectation == nil && mmGetApartments.mock.funcGetApartments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApartments.mock.afterGetApartmentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApartments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApartments implements apartments.ApartmentsService
func (mmGetApartments *ApartmentsServiceMock) GetApartments(ctx context.Context) (a1 models.ApartmentSlice, err error) {
	mm_atomic.AddUint64(&mmGetApartments.beforeGetApartmentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApartments.afterGetApartmentsCounter, 1)

	if mmGetApartments.inspectFuncGetApartments != nil {
		mmGetApartments.inspectFuncGetApartments(ctx)
	}

	mm_params := ApartmentsServiceMockGetApartmentsParams{ctx}

	// Record call args
	mmGetApartments.GetApartmentsMock.mutex.Lock()
	mmGetApartments.GetApartmentsMock.callArgs = append(mmGetApartments.GetApartmentsMock.callArgs, &mm_params)
	mmGetApartments.GetApartmentsMock.mutex.Unlock()

	for _, e := range mmGetApartments.GetApartmentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGetApartments.GetApartmentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApartments.GetApartmentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApartments.GetApartmentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetApartments.GetApartmentsMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsServiceMockGetApartmentsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApartments.t.Errorf("ApartmentsServiceMock.GetApartments got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApartments.t.Errorf("ApartmentsServiceMock.GetApartments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApartments.GetApartmentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApartments.t.Fatal("No results are set for the ApartmentsServiceMock.GetApartments")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGetApartments.funcGetApartments != nil {
		return mmGetApartments.funcGetApartments(ctx)
	}
	mmGetApartments.t.Fatalf("Unexpected call to ApartmentsServiceMock.GetApartments. %v", ctx)
	return
}

// GetApartmentsAfterCounter returns a count of finished ApartmentsServiceMock.GetApartments invocations
func (mmGetApartments *ApartmentsServiceMock) GetApartmentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartments.afterGetApartmentsCounter)
}

// GetApartmentsBeforeCounter returns a count of ApartmentsServiceMock.GetApartments invocations
func (mmGetApartments *ApartmentsServiceMock) GetApartmentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartments.beforeGetApartmentsCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsServiceMock.GetApartments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApartments *mApartmentsServiceMockGetApartments) Calls() []*ApartmentsServiceMockGetApartmentsParams {
	mmGetApartments.mutex.RLock()

	argCopy := make([]*ApartmentsServiceMockGetApartmentsParams, len(mmGetApartments.callArgs))
	copy(argCopy, mmGetApartments.callArgs)

	mmGetApartments.mutex.RUnlock()

	return argCopy
}

// MinimockGetApartmentsDone returns true if the count of the GetApartments invocations corresponds
// the number of defined expectations
func (m *ApartmentsServiceMock) MinimockGetApartmentsDone() bool {
	if m.GetApartmentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApartmentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApartmentsMock.invocationsDone()
}

// MinimockGetApartmentsInspect logs each unmet expectation
func (m *ApartmentsServiceMock) MinimockGetApartmentsInspect() {
	for _, e := range m.GetApartmentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsServiceMock.GetApartments with params: %#v", *e.params)
		}
	}

	afterGetApartmentsCounter := mm_atomic.LoadUint64(&m.afterGetApartmentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApartmentsMock.defaultExpectation != nil && afterGetApartmentsCounter < 1 {
		if m.GetApartmentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsServiceMock.GetApartments")
		} else {
			m.t.Errorf("Expected call to ApartmentsServiceMock.GetApartments with params: %#v", *m.GetApartmentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApartments != nil && afterGetApartmentsCounter < 1 {
		m.t.Error("Expected call to ApartmentsServiceMock.GetApartments")
	}

	if !m.GetApartmentsMock.invocationsDone() && afterGetApartmentsCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsServiceMock.GetApartments but found %d calls",
			mm_atomic.LoadUint64(&m.GetApartmentsMock.expectedInvocations), afterGetApartmentsCounter)
	}
}

type mApartmentsServiceMockGetApartmentsInBuilding struct {
	optional           bool
	mock               *ApartmentsServiceMock
	defaultExpectation *ApartmentsServiceMockGetApartmentsInBuildingExpectation
	expectations       []*ApartmentsServiceMockGetApartmentsInBuildingExpectation

	callArgs []*ApartmentsServiceMockGetApartmentsInBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsServiceMockGetApartmentsInBuildingExpectation specifies expectation struct of the ApartmentsService.GetApartmentsInBuilding
type ApartmentsServiceMockGetApartmentsInBuildingExpectation struct {
	mock      *ApartmentsServiceMock
	params    *ApartmentsServiceMockGetApartmentsInBuildingParams
	paramPtrs *ApartmentsServiceMockGetApartmentsInBuildingParamPtrs
	results   *ApartmentsServiceMockGetApartmentsInBuildingResults
	Counter   uint64
}

// ApartmentsServiceMockGetApartmentsInBuildingParams contains parameters of the ApartmentsService.GetApartmentsInBuilding
type ApartmentsServiceMockGetApartmentsInBuildingParams struct {
	ctx        context.Context
	buildingId int
}

// ApartmentsServiceMockGetApartmentsInBuildingParamPtrs contains pointers to parameters of the ApartmentsService.GetApartmentsInBuilding
type ApartmentsServiceMockGetApartmentsInBuildingParamPtrs struct {
	ctx        *context.Context
	buildingId *int
}

// ApartmentsServiceMockGetApartmentsInBuildingResults contains results of the ApartmentsService.GetApartmentsInBuilding
type ApartmentsServiceMockGetApartmentsInBuildingResults struct {
	a1  models.ApartmentSlice
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Optional() *mApartmentsServiceMockGetApartmentsInBuilding {
	mmGetApartmentsInBuilding.optional = true
	return mmGetApartmentsInBuilding
}

// Expect sets up expected params for ApartmentsService.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Expect(ctx context.Context, buildingId int) *mApartmentsServiceMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsServiceMockGetApartmentsInBuildingExpectation{}
	}

	if mmGetApartmentsInBuilding.defaultExpectation.paramPtrs != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by ExpectParams functions")
	}

	mmGetApartmentsInBuilding.defaultExpectation.params = &ApartmentsServiceMockGetApartmentsInBuildingParams{ctx, buildingId}
	for _, e := range mmGetApartmentsInBuilding.expectations {
		if minimock.Equal(e.params, mmGetApartmentsInBuilding.defaultExpectation.params) {
			mmGetApartmentsInBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApartmentsInBuilding.defaultExpectation.params)
		}
	}

	return mmGetApartmentsInBuilding
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsService.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) ExpectCtxParam1(ctx context.Context) *mApartmentsServiceMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsServiceMockGetApartmentsInBuildingExpectation{}
	}

	if mmGetApartmentsInBuilding.defaultExpectation.params != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Expect")
	}

	if mmGetApartmentsInBuilding.defaultExpectation.paramPtrs == nil {
		mmGetApartmentsInBuilding.defaultExpectation.paramPtrs = &ApartmentsServiceMockGetApartmentsInBuildingParamPtrs{}
	}
	mmGetApartmentsInBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApartmentsInBuilding
}

// ExpectBuildingIdParam2 sets up expected param buildingId for ApartmentsService.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) ExpectBuildingIdParam2(buildingId int) *mApartmentsServiceMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsServiceMockGetApartmentsInBuildingExpectation{}
	}

	if mmGetApartmentsInBuilding.defaultExpectation.params != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Expect")
	}

	if mmGetApartmentsInBuilding.defaultExpectation.paramPtrs == nil {
		mmGetApartmentsInBuilding.defaultExpectation.paramPtrs = &ApartmentsServiceMockGetApartmentsInBuildingParamPtrs{}
	}
	mmGetApartmentsInBuilding.defaultExpectation.paramPtrs.buildingId = &buildingId

	return mmGetApartmentsInBuilding
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsService.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Inspect(f func(ctx context.Context, buildingId int)) *mApartmentsServiceMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.inspectFuncGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Inspect function is already set for ApartmentsServiceMock.GetApartmentsInBuilding")
	}

	mmGetApartmentsInBuilding.mock.inspectFuncGetApartmentsInBuilding = f

	return mmGetApartmentsInBuilding
}

// Return sets up results that will be returned by ApartmentsService.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Return(a1 models.ApartmentSlice, err error) *ApartmentsServiceMock {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsServiceMockGetApartmentsInBuildingExpectation{mock: mmGetApartmentsInBuilding.mock}
	}
	mmGetApartmentsInBuilding.defaultExpectation.results = &ApartmentsServiceMockGetApartmentsInBuildingResults{a1, err}
	return mmGetApartmentsInBuilding.mock
}

// Set uses given function f to mock the ApartmentsService.GetApartmentsInBuilding method
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Set(f func(ctx context.Context, buildingId int) (a1 models.ApartmentSlice, err error)) *ApartmentsServiceMock {
	if mmGetApartmentsInBuilding.defaultExpectation != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Default expectation is already set for the ApartmentsService.GetApartmentsInBuilding method")
	}

	if len(mmGetApartmentsInBuilding.expectations) > 0 {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Some expectations are already set for the ApartmentsService.GetApartmentsInBuilding method")
	}

	mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding = f
	return mmGetApartmentsInBuilding.mock
}

// When sets expectation for the ApartmentsService.GetApartmentsInBuilding which will trigger the result defined by the following
// Then helper
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) When(ctx context.Context, buildingId int) *ApartmentsServiceMockGetApartmentsInBuildingExpectation {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsServiceMock.GetApartmentsInBuilding mock is already set by Set")
	}

	expectation := &ApartmentsServiceMockGetApartmentsInBuildingExpectation{
		mock:   mmGetApartmentsInBuilding.mock,
		params: &ApartmentsServiceMockGetApartmentsInBuildingParams{ctx, buildingId},
	}
	mmGetApartmentsInBuilding.expectations = append(mmGetApartmentsInBuilding.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsService.GetApartmentsInBuilding return parameters for the expectation previously defined by the When method
func (e *ApartmentsServiceMockGetApartmentsInBuildingExpectation) Then(a1 models.ApartmentSlice, err error) *ApartmentsServiceMock {
	e.results = &ApartmentsServiceMockGetApartmentsInBuildingResults{a1, err}
	return e.mock
}

// Times sets number of times ApartmentsService.GetApartmentsInBuilding should be invoked
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Times(n uint64) *mApartmentsServiceMockGetApartmentsInBuilding {
	if n == 0 {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Times of ApartmentsServiceMock.GetApartmentsInBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApartmentsInBuilding.expectedInvocations, n)
	return mmGetApartmentsInBuilding
}

func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) invocationsDone() bool {
	if len(mmGetApartmentsInBuilding.expectations) == 0 && mmGetApartmentsInBuilding.defaultExpectation == nil && mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.mock.afterGetApartmentsInBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApartmentsInBuilding implements apartments.ApartmentsService
func (mmGetApartmentsInBuilding *ApartmentsServiceMock) GetApartmentsInBuilding(ctx context.Context, buildingId int) (a1 models.ApartmentSlice, err error) {
	mm_atomic.AddUint64(&mmGetApartmentsInBuilding.beforeGetApartmentsInBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApartmentsInBuilding.afterGetApartmentsInBuildingCounter, 1)

	if mmGetApartmentsInBuilding.inspectFuncGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.inspectFuncGetApartmentsInBuilding(ctx, buildingId)
	}

	mm_params := ApartmentsServiceMockGetApartmentsInBuildingParams{ctx, buildingId}

	// Record call args
	mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.mutex.Lock()
	mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.callArgs = append(mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.callArgs, &mm_params)
	mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.mutex.Unlock()

	for _, e := range mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsServiceMockGetApartmentsInBuildingParams{ctx, buildingId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApartmentsInBuilding.t.Errorf("ApartmentsServiceMock.GetApartmentsInBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.buildingId != nil && !minimock.Equal(*mm_want_ptrs.buildingId, mm_got.buildingId) {
				mmGetApartmentsInBuilding.t.Errorf("ApartmentsServiceMock.GetApartmentsInBuilding got unexpected parameter buildingId, want: %#v, got: %#v%s\n", *mm_want_ptrs.buildingId, mm_got.buildingId, minimock.Diff(*mm_want_ptrs.buildingId, mm_got.buildingId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApartmentsInBuilding.t.Errorf("ApartmentsServiceMock.GetApartmentsInBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApartmentsInBuilding.t.Fatal("No results are set for the ApartmentsServiceMock.GetApartmentsInBuilding")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGetApartmentsInBuilding.funcGetApartmentsInBuilding != nil {
		return mmGetApartmentsInBuilding.funcGetApartmentsInBuilding(ctx, buildingId)
	}
	mmGetApartmentsInBuilding.t.Fatalf("Unexpected call to ApartmentsServiceMock.GetApartmentsInBuilding. %v %v", ctx, buildingId)
	return
}

// GetApartmentsInBuildingAfterCounter returns a count of finished ApartmentsServiceMock.GetApartmentsInBuilding invocations
func (mmGetApartmentsInBuilding *ApartmentsServiceMock) GetApartmentsInBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.afterGetApartmentsInBuildingCounter)
}

// GetApartmentsInBuildingBeforeCounter returns a count of ApartmentsServiceMock.GetApartmentsInBuilding invocations
func (mmGetApartmentsInBuilding *ApartmentsServiceMock) GetApartmentsInBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.beforeGetApartmentsInBuildingCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsServiceMock.GetApartmentsInBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApartmentsInBuilding *mApartmentsServiceMockGetApartmentsInBuilding) Calls() []*ApartmentsServiceMockGetApartmentsInBuildingParams {
	mmGetApartmentsInBuilding.mutex.RLock()

	argCopy := make([]*ApartmentsServiceMockGetApartmentsInBuildingParams, len(mmGetApartmentsInBuilding.callArgs))
	copy(argCopy, mmGetApartmentsInBuilding.callArgs)

	mmGetApartmentsInBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockGetApartmentsInBuildingDone returns true if the count of the GetApartmentsInBuilding invocations corresponds
// the number of defined expectations
func (m *ApartmentsServiceMock) MinimockGetApartmentsInBuildingDone() bool {
	if m.GetApartmentsInBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApartmentsInBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApartmentsInBuildingMock.invocationsDone()
}

// MinimockGetApartmentsInBuildingInspect logs each unmet expectation
func (m *ApartmentsServiceMock) MinimockGetApartmentsInBuildingInspect() {
	for _, e := range m.GetApartmentsInBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsServiceMock.GetApartmentsInBuilding with params: %#v", *e.params)
		}
	}

	afterGetApartmentsInBuildingCounter := mm_atomic.LoadUint64(&m.afterGetApartmentsInBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApartmentsInBuildingMock.defaultExpectation != nil && afterGetApartmentsInBuildingCounter < 1 {
		if m.GetApartmentsInBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsServiceMock.GetApartmentsInBuilding")
		} else {
			m.t.Errorf("Expected call to ApartmentsServiceMock.GetApartmentsInBuilding with params: %#v", *m.GetApartmentsInBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApartmentsInBuilding != nil && afterGetApartmentsInBuildingCounter < 1 {
		m.t.Error("Expected call to ApartmentsServiceMock.GetApartmentsInBuilding")
	}

	if !m.GetApartmentsInBuildingMock.invocationsDone() && afterGetApartmentsInBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsServiceMock.GetApartmentsInBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.GetApartmentsInBuildingMock.expectedInvocations), afterGetApartmentsInBuildingCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ApartmentsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateApartmentInspect()

			m.MinimockDeleteApartmentInspect()

			m.MinimockGetApartmentInspect()

			m.MinimockGetApartmentsInspect()

			m.MinimockGetApartmentsInBuildingInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ApartmentsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ApartmentsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateApartmentDone() &&
		m.MinimockDeleteApartmentDone() &&
		m.MinimockGetApartmentDone() &&
		m.MinimockGetApartmentsDone() &&
		m.MinimockGetApartmentsInBuildingDone()
}
