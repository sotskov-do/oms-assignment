// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sotskov-do/oms-assignment/internal/storage.BuildingsStorage -o buildings_storage_mock_test.go -n BuildingsStorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sotskov-do/oms-assignment/internal/models"
)

// BuildingsStorageMock implements storage.BuildingsStorage
type BuildingsStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateBuilding          func(ctx context.Context, building *models.Building) (err error)
	inspectFuncCreateBuilding   func(ctx context.Context, building *models.Building)
	afterCreateBuildingCounter  uint64
	beforeCreateBuildingCounter uint64
	CreateBuildingMock          mBuildingsStorageMockCreateBuilding

	funcDeleteBuilding          func(ctx context.Context, id int) (i1 int64, err error)
	inspectFuncDeleteBuilding   func(ctx context.Context, id int)
	afterDeleteBuildingCounter  uint64
	beforeDeleteBuildingCounter uint64
	DeleteBuildingMock          mBuildingsStorageMockDeleteBuilding

	funcGetBuilding          func(ctx context.Context, id int) (bp1 *models.Building, err error)
	inspectFuncGetBuilding   func(ctx context.Context, id int)
	afterGetBuildingCounter  uint64
	beforeGetBuildingCounter uint64
	GetBuildingMock          mBuildingsStorageMockGetBuilding

	funcGetBuildings          func(ctx context.Context) (b1 models.BuildingSlice, err error)
	inspectFuncGetBuildings   func(ctx context.Context)
	afterGetBuildingsCounter  uint64
	beforeGetBuildingsCounter uint64
	GetBuildingsMock          mBuildingsStorageMockGetBuildings
}

// NewBuildingsStorageMock returns a mock for storage.BuildingsStorage
func NewBuildingsStorageMock(t minimock.Tester) *BuildingsStorageMock {
	m := &BuildingsStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBuildingMock = mBuildingsStorageMockCreateBuilding{mock: m}
	m.CreateBuildingMock.callArgs = []*BuildingsStorageMockCreateBuildingParams{}

	m.DeleteBuildingMock = mBuildingsStorageMockDeleteBuilding{mock: m}
	m.DeleteBuildingMock.callArgs = []*BuildingsStorageMockDeleteBuildingParams{}

	m.GetBuildingMock = mBuildingsStorageMockGetBuilding{mock: m}
	m.GetBuildingMock.callArgs = []*BuildingsStorageMockGetBuildingParams{}

	m.GetBuildingsMock = mBuildingsStorageMockGetBuildings{mock: m}
	m.GetBuildingsMock.callArgs = []*BuildingsStorageMockGetBuildingsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBuildingsStorageMockCreateBuilding struct {
	optional           bool
	mock               *BuildingsStorageMock
	defaultExpectation *BuildingsStorageMockCreateBuildingExpectation
	expectations       []*BuildingsStorageMockCreateBuildingExpectation

	callArgs []*BuildingsStorageMockCreateBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsStorageMockCreateBuildingExpectation specifies expectation struct of the BuildingsStorage.CreateBuilding
type BuildingsStorageMockCreateBuildingExpectation struct {
	mock      *BuildingsStorageMock
	params    *BuildingsStorageMockCreateBuildingParams
	paramPtrs *BuildingsStorageMockCreateBuildingParamPtrs
	results   *BuildingsStorageMockCreateBuildingResults
	Counter   uint64
}

// BuildingsStorageMockCreateBuildingParams contains parameters of the BuildingsStorage.CreateBuilding
type BuildingsStorageMockCreateBuildingParams struct {
	ctx      context.Context
	building *models.Building
}

// BuildingsStorageMockCreateBuildingParamPtrs contains pointers to parameters of the BuildingsStorage.CreateBuilding
type BuildingsStorageMockCreateBuildingParamPtrs struct {
	ctx      *context.Context
	building **models.Building
}

// BuildingsStorageMockCreateBuildingResults contains results of the BuildingsStorage.CreateBuilding
type BuildingsStorageMockCreateBuildingResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Optional() *mBuildingsStorageMockCreateBuilding {
	mmCreateBuilding.optional = true
	return mmCreateBuilding
}

// Expect sets up expected params for BuildingsStorage.CreateBuilding
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Expect(ctx context.Context, building *models.Building) *mBuildingsStorageMockCreateBuilding {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsStorageMockCreateBuildingExpectation{}
	}

	if mmCreateBuilding.defaultExpectation.paramPtrs != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by ExpectParams functions")
	}

	mmCreateBuilding.defaultExpectation.params = &BuildingsStorageMockCreateBuildingParams{ctx, building}
	for _, e := range mmCreateBuilding.expectations {
		if minimock.Equal(e.params, mmCreateBuilding.defaultExpectation.params) {
			mmCreateBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBuilding.defaultExpectation.params)
		}
	}

	return mmCreateBuilding
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsStorage.CreateBuilding
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) ExpectCtxParam1(ctx context.Context) *mBuildingsStorageMockCreateBuilding {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsStorageMockCreateBuildingExpectation{}
	}

	if mmCreateBuilding.defaultExpectation.params != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Expect")
	}

	if mmCreateBuilding.defaultExpectation.paramPtrs == nil {
		mmCreateBuilding.defaultExpectation.paramPtrs = &BuildingsStorageMockCreateBuildingParamPtrs{}
	}
	mmCreateBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateBuilding
}

// ExpectBuildingParam2 sets up expected param building for BuildingsStorage.CreateBuilding
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) ExpectBuildingParam2(building *models.Building) *mBuildingsStorageMockCreateBuilding {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsStorageMockCreateBuildingExpectation{}
	}

	if mmCreateBuilding.defaultExpectation.params != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Expect")
	}

	if mmCreateBuilding.defaultExpectation.paramPtrs == nil {
		mmCreateBuilding.defaultExpectation.paramPtrs = &BuildingsStorageMockCreateBuildingParamPtrs{}
	}
	mmCreateBuilding.defaultExpectation.paramPtrs.building = &building

	return mmCreateBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingsStorage.CreateBuilding
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Inspect(f func(ctx context.Context, building *models.Building)) *mBuildingsStorageMockCreateBuilding {
	if mmCreateBuilding.mock.inspectFuncCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("Inspect function is already set for BuildingsStorageMock.CreateBuilding")
	}

	mmCreateBuilding.mock.inspectFuncCreateBuilding = f

	return mmCreateBuilding
}

// Return sets up results that will be returned by BuildingsStorage.CreateBuilding
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Return(err error) *BuildingsStorageMock {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Set")
	}

	if mmCreateBuilding.defaultExpectation == nil {
		mmCreateBuilding.defaultExpectation = &BuildingsStorageMockCreateBuildingExpectation{mock: mmCreateBuilding.mock}
	}
	mmCreateBuilding.defaultExpectation.results = &BuildingsStorageMockCreateBuildingResults{err}
	return mmCreateBuilding.mock
}

// Set uses given function f to mock the BuildingsStorage.CreateBuilding method
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Set(f func(ctx context.Context, building *models.Building) (err error)) *BuildingsStorageMock {
	if mmCreateBuilding.defaultExpectation != nil {
		mmCreateBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingsStorage.CreateBuilding method")
	}

	if len(mmCreateBuilding.expectations) > 0 {
		mmCreateBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingsStorage.CreateBuilding method")
	}

	mmCreateBuilding.mock.funcCreateBuilding = f
	return mmCreateBuilding.mock
}

// When sets expectation for the BuildingsStorage.CreateBuilding which will trigger the result defined by the following
// Then helper
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) When(ctx context.Context, building *models.Building) *BuildingsStorageMockCreateBuildingExpectation {
	if mmCreateBuilding.mock.funcCreateBuilding != nil {
		mmCreateBuilding.mock.t.Fatalf("BuildingsStorageMock.CreateBuilding mock is already set by Set")
	}

	expectation := &BuildingsStorageMockCreateBuildingExpectation{
		mock:   mmCreateBuilding.mock,
		params: &BuildingsStorageMockCreateBuildingParams{ctx, building},
	}
	mmCreateBuilding.expectations = append(mmCreateBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingsStorage.CreateBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingsStorageMockCreateBuildingExpectation) Then(err error) *BuildingsStorageMock {
	e.results = &BuildingsStorageMockCreateBuildingResults{err}
	return e.mock
}

// Times sets number of times BuildingsStorage.CreateBuilding should be invoked
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Times(n uint64) *mBuildingsStorageMockCreateBuilding {
	if n == 0 {
		mmCreateBuilding.mock.t.Fatalf("Times of BuildingsStorageMock.CreateBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateBuilding.expectedInvocations, n)
	return mmCreateBuilding
}

func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) invocationsDone() bool {
	if len(mmCreateBuilding.expectations) == 0 && mmCreateBuilding.defaultExpectation == nil && mmCreateBuilding.mock.funcCreateBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateBuilding.mock.afterCreateBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateBuilding implements storage.BuildingsStorage
func (mmCreateBuilding *BuildingsStorageMock) CreateBuilding(ctx context.Context, building *models.Building) (err error) {
	mm_atomic.AddUint64(&mmCreateBuilding.beforeCreateBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBuilding.afterCreateBuildingCounter, 1)

	if mmCreateBuilding.inspectFuncCreateBuilding != nil {
		mmCreateBuilding.inspectFuncCreateBuilding(ctx, building)
	}

	mm_params := BuildingsStorageMockCreateBuildingParams{ctx, building}

	// Record call args
	mmCreateBuilding.CreateBuildingMock.mutex.Lock()
	mmCreateBuilding.CreateBuildingMock.callArgs = append(mmCreateBuilding.CreateBuildingMock.callArgs, &mm_params)
	mmCreateBuilding.CreateBuildingMock.mutex.Unlock()

	for _, e := range mmCreateBuilding.CreateBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateBuilding.CreateBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBuilding.CreateBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBuilding.CreateBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmCreateBuilding.CreateBuildingMock.defaultExpectation.paramPtrs

		mm_got := BuildingsStorageMockCreateBuildingParams{ctx, building}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateBuilding.t.Errorf("BuildingsStorageMock.CreateBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.building != nil && !minimock.Equal(*mm_want_ptrs.building, mm_got.building) {
				mmCreateBuilding.t.Errorf("BuildingsStorageMock.CreateBuilding got unexpected parameter building, want: %#v, got: %#v%s\n", *mm_want_ptrs.building, mm_got.building, minimock.Diff(*mm_want_ptrs.building, mm_got.building))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBuilding.t.Errorf("BuildingsStorageMock.CreateBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBuilding.CreateBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBuilding.t.Fatal("No results are set for the BuildingsStorageMock.CreateBuilding")
		}
		return (*mm_results).err
	}
	if mmCreateBuilding.funcCreateBuilding != nil {
		return mmCreateBuilding.funcCreateBuilding(ctx, building)
	}
	mmCreateBuilding.t.Fatalf("Unexpected call to BuildingsStorageMock.CreateBuilding. %v %v", ctx, building)
	return
}

// CreateBuildingAfterCounter returns a count of finished BuildingsStorageMock.CreateBuilding invocations
func (mmCreateBuilding *BuildingsStorageMock) CreateBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilding.afterCreateBuildingCounter)
}

// CreateBuildingBeforeCounter returns a count of BuildingsStorageMock.CreateBuilding invocations
func (mmCreateBuilding *BuildingsStorageMock) CreateBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilding.beforeCreateBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingsStorageMock.CreateBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBuilding *mBuildingsStorageMockCreateBuilding) Calls() []*BuildingsStorageMockCreateBuildingParams {
	mmCreateBuilding.mutex.RLock()

	argCopy := make([]*BuildingsStorageMockCreateBuildingParams, len(mmCreateBuilding.callArgs))
	copy(argCopy, mmCreateBuilding.callArgs)

	mmCreateBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBuildingDone returns true if the count of the CreateBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingsStorageMock) MinimockCreateBuildingDone() bool {
	if m.CreateBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateBuildingMock.invocationsDone()
}

// MinimockCreateBuildingInspect logs each unmet expectation
func (m *BuildingsStorageMock) MinimockCreateBuildingInspect() {
	for _, e := range m.CreateBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsStorageMock.CreateBuilding with params: %#v", *e.params)
		}
	}

	afterCreateBuildingCounter := mm_atomic.LoadUint64(&m.afterCreateBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBuildingMock.defaultExpectation != nil && afterCreateBuildingCounter < 1 {
		if m.CreateBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsStorageMock.CreateBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingsStorageMock.CreateBuilding with params: %#v", *m.CreateBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBuilding != nil && afterCreateBuildingCounter < 1 {
		m.t.Error("Expected call to BuildingsStorageMock.CreateBuilding")
	}

	if !m.CreateBuildingMock.invocationsDone() && afterCreateBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsStorageMock.CreateBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.CreateBuildingMock.expectedInvocations), afterCreateBuildingCounter)
	}
}

type mBuildingsStorageMockDeleteBuilding struct {
	optional           bool
	mock               *BuildingsStorageMock
	defaultExpectation *BuildingsStorageMockDeleteBuildingExpectation
	expectations       []*BuildingsStorageMockDeleteBuildingExpectation

	callArgs []*BuildingsStorageMockDeleteBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsStorageMockDeleteBuildingExpectation specifies expectation struct of the BuildingsStorage.DeleteBuilding
type BuildingsStorageMockDeleteBuildingExpectation struct {
	mock      *BuildingsStorageMock
	params    *BuildingsStorageMockDeleteBuildingParams
	paramPtrs *BuildingsStorageMockDeleteBuildingParamPtrs
	results   *BuildingsStorageMockDeleteBuildingResults
	Counter   uint64
}

// BuildingsStorageMockDeleteBuildingParams contains parameters of the BuildingsStorage.DeleteBuilding
type BuildingsStorageMockDeleteBuildingParams struct {
	ctx context.Context
	id  int
}

// BuildingsStorageMockDeleteBuildingParamPtrs contains pointers to parameters of the BuildingsStorage.DeleteBuilding
type BuildingsStorageMockDeleteBuildingParamPtrs struct {
	ctx *context.Context
	id  *int
}

// BuildingsStorageMockDeleteBuildingResults contains results of the BuildingsStorage.DeleteBuilding
type BuildingsStorageMockDeleteBuildingResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Optional() *mBuildingsStorageMockDeleteBuilding {
	mmDeleteBuilding.optional = true
	return mmDeleteBuilding
}

// Expect sets up expected params for BuildingsStorage.DeleteBuilding
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Expect(ctx context.Context, id int) *mBuildingsStorageMockDeleteBuilding {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsStorageMockDeleteBuildingExpectation{}
	}

	if mmDeleteBuilding.defaultExpectation.paramPtrs != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by ExpectParams functions")
	}

	mmDeleteBuilding.defaultExpectation.params = &BuildingsStorageMockDeleteBuildingParams{ctx, id}
	for _, e := range mmDeleteBuilding.expectations {
		if minimock.Equal(e.params, mmDeleteBuilding.defaultExpectation.params) {
			mmDeleteBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBuilding.defaultExpectation.params)
		}
	}

	return mmDeleteBuilding
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsStorage.DeleteBuilding
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) ExpectCtxParam1(ctx context.Context) *mBuildingsStorageMockDeleteBuilding {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsStorageMockDeleteBuildingExpectation{}
	}

	if mmDeleteBuilding.defaultExpectation.params != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Expect")
	}

	if mmDeleteBuilding.defaultExpectation.paramPtrs == nil {
		mmDeleteBuilding.defaultExpectation.paramPtrs = &BuildingsStorageMockDeleteBuildingParamPtrs{}
	}
	mmDeleteBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteBuilding
}

// ExpectIdParam2 sets up expected param id for BuildingsStorage.DeleteBuilding
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) ExpectIdParam2(id int) *mBuildingsStorageMockDeleteBuilding {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsStorageMockDeleteBuildingExpectation{}
	}

	if mmDeleteBuilding.defaultExpectation.params != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Expect")
	}

	if mmDeleteBuilding.defaultExpectation.paramPtrs == nil {
		mmDeleteBuilding.defaultExpectation.paramPtrs = &BuildingsStorageMockDeleteBuildingParamPtrs{}
	}
	mmDeleteBuilding.defaultExpectation.paramPtrs.id = &id

	return mmDeleteBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingsStorage.DeleteBuilding
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Inspect(f func(ctx context.Context, id int)) *mBuildingsStorageMockDeleteBuilding {
	if mmDeleteBuilding.mock.inspectFuncDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("Inspect function is already set for BuildingsStorageMock.DeleteBuilding")
	}

	mmDeleteBuilding.mock.inspectFuncDeleteBuilding = f

	return mmDeleteBuilding
}

// Return sets up results that will be returned by BuildingsStorage.DeleteBuilding
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Return(i1 int64, err error) *BuildingsStorageMock {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Set")
	}

	if mmDeleteBuilding.defaultExpectation == nil {
		mmDeleteBuilding.defaultExpectation = &BuildingsStorageMockDeleteBuildingExpectation{mock: mmDeleteBuilding.mock}
	}
	mmDeleteBuilding.defaultExpectation.results = &BuildingsStorageMockDeleteBuildingResults{i1, err}
	return mmDeleteBuilding.mock
}

// Set uses given function f to mock the BuildingsStorage.DeleteBuilding method
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Set(f func(ctx context.Context, id int) (i1 int64, err error)) *BuildingsStorageMock {
	if mmDeleteBuilding.defaultExpectation != nil {
		mmDeleteBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingsStorage.DeleteBuilding method")
	}

	if len(mmDeleteBuilding.expectations) > 0 {
		mmDeleteBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingsStorage.DeleteBuilding method")
	}

	mmDeleteBuilding.mock.funcDeleteBuilding = f
	return mmDeleteBuilding.mock
}

// When sets expectation for the BuildingsStorage.DeleteBuilding which will trigger the result defined by the following
// Then helper
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) When(ctx context.Context, id int) *BuildingsStorageMockDeleteBuildingExpectation {
	if mmDeleteBuilding.mock.funcDeleteBuilding != nil {
		mmDeleteBuilding.mock.t.Fatalf("BuildingsStorageMock.DeleteBuilding mock is already set by Set")
	}

	expectation := &BuildingsStorageMockDeleteBuildingExpectation{
		mock:   mmDeleteBuilding.mock,
		params: &BuildingsStorageMockDeleteBuildingParams{ctx, id},
	}
	mmDeleteBuilding.expectations = append(mmDeleteBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingsStorage.DeleteBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingsStorageMockDeleteBuildingExpectation) Then(i1 int64, err error) *BuildingsStorageMock {
	e.results = &BuildingsStorageMockDeleteBuildingResults{i1, err}
	return e.mock
}

// Times sets number of times BuildingsStorage.DeleteBuilding should be invoked
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Times(n uint64) *mBuildingsStorageMockDeleteBuilding {
	if n == 0 {
		mmDeleteBuilding.mock.t.Fatalf("Times of BuildingsStorageMock.DeleteBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteBuilding.expectedInvocations, n)
	return mmDeleteBuilding
}

func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) invocationsDone() bool {
	if len(mmDeleteBuilding.expectations) == 0 && mmDeleteBuilding.defaultExpectation == nil && mmDeleteBuilding.mock.funcDeleteBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteBuilding.mock.afterDeleteBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteBuilding implements storage.BuildingsStorage
func (mmDeleteBuilding *BuildingsStorageMock) DeleteBuilding(ctx context.Context, id int) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDeleteBuilding.beforeDeleteBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBuilding.afterDeleteBuildingCounter, 1)

	if mmDeleteBuilding.inspectFuncDeleteBuilding != nil {
		mmDeleteBuilding.inspectFuncDeleteBuilding(ctx, id)
	}

	mm_params := BuildingsStorageMockDeleteBuildingParams{ctx, id}

	// Record call args
	mmDeleteBuilding.DeleteBuildingMock.mutex.Lock()
	mmDeleteBuilding.DeleteBuildingMock.callArgs = append(mmDeleteBuilding.DeleteBuildingMock.callArgs, &mm_params)
	mmDeleteBuilding.DeleteBuildingMock.mutex.Unlock()

	for _, e := range mmDeleteBuilding.DeleteBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDeleteBuilding.DeleteBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.paramPtrs

		mm_got := BuildingsStorageMockDeleteBuildingParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteBuilding.t.Errorf("BuildingsStorageMock.DeleteBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteBuilding.t.Errorf("BuildingsStorageMock.DeleteBuilding got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBuilding.t.Errorf("BuildingsStorageMock.DeleteBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBuilding.DeleteBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBuilding.t.Fatal("No results are set for the BuildingsStorageMock.DeleteBuilding")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDeleteBuilding.funcDeleteBuilding != nil {
		return mmDeleteBuilding.funcDeleteBuilding(ctx, id)
	}
	mmDeleteBuilding.t.Fatalf("Unexpected call to BuildingsStorageMock.DeleteBuilding. %v %v", ctx, id)
	return
}

// DeleteBuildingAfterCounter returns a count of finished BuildingsStorageMock.DeleteBuilding invocations
func (mmDeleteBuilding *BuildingsStorageMock) DeleteBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBuilding.afterDeleteBuildingCounter)
}

// DeleteBuildingBeforeCounter returns a count of BuildingsStorageMock.DeleteBuilding invocations
func (mmDeleteBuilding *BuildingsStorageMock) DeleteBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBuilding.beforeDeleteBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingsStorageMock.DeleteBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBuilding *mBuildingsStorageMockDeleteBuilding) Calls() []*BuildingsStorageMockDeleteBuildingParams {
	mmDeleteBuilding.mutex.RLock()

	argCopy := make([]*BuildingsStorageMockDeleteBuildingParams, len(mmDeleteBuilding.callArgs))
	copy(argCopy, mmDeleteBuilding.callArgs)

	mmDeleteBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBuildingDone returns true if the count of the DeleteBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingsStorageMock) MinimockDeleteBuildingDone() bool {
	if m.DeleteBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteBuildingMock.invocationsDone()
}

// MinimockDeleteBuildingInspect logs each unmet expectation
func (m *BuildingsStorageMock) MinimockDeleteBuildingInspect() {
	for _, e := range m.DeleteBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsStorageMock.DeleteBuilding with params: %#v", *e.params)
		}
	}

	afterDeleteBuildingCounter := mm_atomic.LoadUint64(&m.afterDeleteBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBuildingMock.defaultExpectation != nil && afterDeleteBuildingCounter < 1 {
		if m.DeleteBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsStorageMock.DeleteBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingsStorageMock.DeleteBuilding with params: %#v", *m.DeleteBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBuilding != nil && afterDeleteBuildingCounter < 1 {
		m.t.Error("Expected call to BuildingsStorageMock.DeleteBuilding")
	}

	if !m.DeleteBuildingMock.invocationsDone() && afterDeleteBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsStorageMock.DeleteBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteBuildingMock.expectedInvocations), afterDeleteBuildingCounter)
	}
}

type mBuildingsStorageMockGetBuilding struct {
	optional           bool
	mock               *BuildingsStorageMock
	defaultExpectation *BuildingsStorageMockGetBuildingExpectation
	expectations       []*BuildingsStorageMockGetBuildingExpectation

	callArgs []*BuildingsStorageMockGetBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsStorageMockGetBuildingExpectation specifies expectation struct of the BuildingsStorage.GetBuilding
type BuildingsStorageMockGetBuildingExpectation struct {
	mock      *BuildingsStorageMock
	params    *BuildingsStorageMockGetBuildingParams
	paramPtrs *BuildingsStorageMockGetBuildingParamPtrs
	results   *BuildingsStorageMockGetBuildingResults
	Counter   uint64
}

// BuildingsStorageMockGetBuildingParams contains parameters of the BuildingsStorage.GetBuilding
type BuildingsStorageMockGetBuildingParams struct {
	ctx context.Context
	id  int
}

// BuildingsStorageMockGetBuildingParamPtrs contains pointers to parameters of the BuildingsStorage.GetBuilding
type BuildingsStorageMockGetBuildingParamPtrs struct {
	ctx *context.Context
	id  *int
}

// BuildingsStorageMockGetBuildingResults contains results of the BuildingsStorage.GetBuilding
type BuildingsStorageMockGetBuildingResults struct {
	bp1 *models.Building
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Optional() *mBuildingsStorageMockGetBuilding {
	mmGetBuilding.optional = true
	return mmGetBuilding
}

// Expect sets up expected params for BuildingsStorage.GetBuilding
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Expect(ctx context.Context, id int) *mBuildingsStorageMockGetBuilding {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsStorageMockGetBuildingExpectation{}
	}

	if mmGetBuilding.defaultExpectation.paramPtrs != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by ExpectParams functions")
	}

	mmGetBuilding.defaultExpectation.params = &BuildingsStorageMockGetBuildingParams{ctx, id}
	for _, e := range mmGetBuilding.expectations {
		if minimock.Equal(e.params, mmGetBuilding.defaultExpectation.params) {
			mmGetBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBuilding.defaultExpectation.params)
		}
	}

	return mmGetBuilding
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsStorage.GetBuilding
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) ExpectCtxParam1(ctx context.Context) *mBuildingsStorageMockGetBuilding {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsStorageMockGetBuildingExpectation{}
	}

	if mmGetBuilding.defaultExpectation.params != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Expect")
	}

	if mmGetBuilding.defaultExpectation.paramPtrs == nil {
		mmGetBuilding.defaultExpectation.paramPtrs = &BuildingsStorageMockGetBuildingParamPtrs{}
	}
	mmGetBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBuilding
}

// ExpectIdParam2 sets up expected param id for BuildingsStorage.GetBuilding
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) ExpectIdParam2(id int) *mBuildingsStorageMockGetBuilding {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsStorageMockGetBuildingExpectation{}
	}

	if mmGetBuilding.defaultExpectation.params != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Expect")
	}

	if mmGetBuilding.defaultExpectation.paramPtrs == nil {
		mmGetBuilding.defaultExpectation.paramPtrs = &BuildingsStorageMockGetBuildingParamPtrs{}
	}
	mmGetBuilding.defaultExpectation.paramPtrs.id = &id

	return mmGetBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingsStorage.GetBuilding
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Inspect(f func(ctx context.Context, id int)) *mBuildingsStorageMockGetBuilding {
	if mmGetBuilding.mock.inspectFuncGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("Inspect function is already set for BuildingsStorageMock.GetBuilding")
	}

	mmGetBuilding.mock.inspectFuncGetBuilding = f

	return mmGetBuilding
}

// Return sets up results that will be returned by BuildingsStorage.GetBuilding
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Return(bp1 *models.Building, err error) *BuildingsStorageMock {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Set")
	}

	if mmGetBuilding.defaultExpectation == nil {
		mmGetBuilding.defaultExpectation = &BuildingsStorageMockGetBuildingExpectation{mock: mmGetBuilding.mock}
	}
	mmGetBuilding.defaultExpectation.results = &BuildingsStorageMockGetBuildingResults{bp1, err}
	return mmGetBuilding.mock
}

// Set uses given function f to mock the BuildingsStorage.GetBuilding method
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Set(f func(ctx context.Context, id int) (bp1 *models.Building, err error)) *BuildingsStorageMock {
	if mmGetBuilding.defaultExpectation != nil {
		mmGetBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingsStorage.GetBuilding method")
	}

	if len(mmGetBuilding.expectations) > 0 {
		mmGetBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingsStorage.GetBuilding method")
	}

	mmGetBuilding.mock.funcGetBuilding = f
	return mmGetBuilding.mock
}

// When sets expectation for the BuildingsStorage.GetBuilding which will trigger the result defined by the following
// Then helper
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) When(ctx context.Context, id int) *BuildingsStorageMockGetBuildingExpectation {
	if mmGetBuilding.mock.funcGetBuilding != nil {
		mmGetBuilding.mock.t.Fatalf("BuildingsStorageMock.GetBuilding mock is already set by Set")
	}

	expectation := &BuildingsStorageMockGetBuildingExpectation{
		mock:   mmGetBuilding.mock,
		params: &BuildingsStorageMockGetBuildingParams{ctx, id},
	}
	mmGetBuilding.expectations = append(mmGetBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingsStorage.GetBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingsStorageMockGetBuildingExpectation) Then(bp1 *models.Building, err error) *BuildingsStorageMock {
	e.results = &BuildingsStorageMockGetBuildingResults{bp1, err}
	return e.mock
}

// Times sets number of times BuildingsStorage.GetBuilding should be invoked
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Times(n uint64) *mBuildingsStorageMockGetBuilding {
	if n == 0 {
		mmGetBuilding.mock.t.Fatalf("Times of BuildingsStorageMock.GetBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBuilding.expectedInvocations, n)
	return mmGetBuilding
}

func (mmGetBuilding *mBuildingsStorageMockGetBuilding) invocationsDone() bool {
	if len(mmGetBuilding.expectations) == 0 && mmGetBuilding.defaultExpectation == nil && mmGetBuilding.mock.funcGetBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBuilding.mock.afterGetBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBuilding implements storage.BuildingsStorage
func (mmGetBuilding *BuildingsStorageMock) GetBuilding(ctx context.Context, id int) (bp1 *models.Building, err error) {
	mm_atomic.AddUint64(&mmGetBuilding.beforeGetBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBuilding.afterGetBuildingCounter, 1)

	if mmGetBuilding.inspectFuncGetBuilding != nil {
		mmGetBuilding.inspectFuncGetBuilding(ctx, id)
	}

	mm_params := BuildingsStorageMockGetBuildingParams{ctx, id}

	// Record call args
	mmGetBuilding.GetBuildingMock.mutex.Lock()
	mmGetBuilding.GetBuildingMock.callArgs = append(mmGetBuilding.GetBuildingMock.callArgs, &mm_params)
	mmGetBuilding.GetBuildingMock.mutex.Unlock()

	for _, e := range mmGetBuilding.GetBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBuilding.GetBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBuilding.GetBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBuilding.GetBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmGetBuilding.GetBuildingMock.defaultExpectation.paramPtrs

		mm_got := BuildingsStorageMockGetBuildingParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBuilding.t.Errorf("BuildingsStorageMock.GetBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetBuilding.t.Errorf("BuildingsStorageMock.GetBuilding got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBuilding.t.Errorf("BuildingsStorageMock.GetBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBuilding.GetBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBuilding.t.Fatal("No results are set for the BuildingsStorageMock.GetBuilding")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBuilding.funcGetBuilding != nil {
		return mmGetBuilding.funcGetBuilding(ctx, id)
	}
	mmGetBuilding.t.Fatalf("Unexpected call to BuildingsStorageMock.GetBuilding. %v %v", ctx, id)
	return
}

// GetBuildingAfterCounter returns a count of finished BuildingsStorageMock.GetBuilding invocations
func (mmGetBuilding *BuildingsStorageMock) GetBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuilding.afterGetBuildingCounter)
}

// GetBuildingBeforeCounter returns a count of BuildingsStorageMock.GetBuilding invocations
func (mmGetBuilding *BuildingsStorageMock) GetBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuilding.beforeGetBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingsStorageMock.GetBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBuilding *mBuildingsStorageMockGetBuilding) Calls() []*BuildingsStorageMockGetBuildingParams {
	mmGetBuilding.mutex.RLock()

	argCopy := make([]*BuildingsStorageMockGetBuildingParams, len(mmGetBuilding.callArgs))
	copy(argCopy, mmGetBuilding.callArgs)

	mmGetBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockGetBuildingDone returns true if the count of the GetBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingsStorageMock) MinimockGetBuildingDone() bool {
	if m.GetBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBuildingMock.invocationsDone()
}

// MinimockGetBuildingInspect logs each unmet expectation
func (m *BuildingsStorageMock) MinimockGetBuildingInspect() {
	for _, e := range m.GetBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsStorageMock.GetBuilding with params: %#v", *e.params)
		}
	}

	afterGetBuildingCounter := mm_atomic.LoadUint64(&m.afterGetBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBuildingMock.defaultExpectation != nil && afterGetBuildingCounter < 1 {
		if m.GetBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsStorageMock.GetBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingsStorageMock.GetBuilding with params: %#v", *m.GetBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBuilding != nil && afterGetBuildingCounter < 1 {
		m.t.Error("Expected call to BuildingsStorageMock.GetBuilding")
	}

	if !m.GetBuildingMock.invocationsDone() && afterGetBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsStorageMock.GetBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.GetBuildingMock.expectedInvocations), afterGetBuildingCounter)
	}
}

type mBuildingsStorageMockGetBuildings struct {
	optional           bool
	mock               *BuildingsStorageMock
	defaultExpectation *BuildingsStorageMockGetBuildingsExpectation
	expectations       []*BuildingsStorageMockGetBuildingsExpectation

	callArgs []*BuildingsStorageMockGetBuildingsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// BuildingsStorageMockGetBuildingsExpectation specifies expectation struct of the BuildingsStorage.GetBuildings
type BuildingsStorageMockGetBuildingsExpectation struct {
	mock      *BuildingsStorageMock
	params    *BuildingsStorageMockGetBuildingsParams
	paramPtrs *BuildingsStorageMockGetBuildingsParamPtrs
	results   *BuildingsStorageMockGetBuildingsResults
	Counter   uint64
}

// BuildingsStorageMockGetBuildingsParams contains parameters of the BuildingsStorage.GetBuildings
type BuildingsStorageMockGetBuildingsParams struct {
	ctx context.Context
}

// BuildingsStorageMockGetBuildingsParamPtrs contains pointers to parameters of the BuildingsStorage.GetBuildings
type BuildingsStorageMockGetBuildingsParamPtrs struct {
	ctx *context.Context
}

// BuildingsStorageMockGetBuildingsResults contains results of the BuildingsStorage.GetBuildings
type BuildingsStorageMockGetBuildingsResults struct {
	b1  models.BuildingSlice
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Optional() *mBuildingsStorageMockGetBuildings {
	mmGetBuildings.optional = true
	return mmGetBuildings
}

// Expect sets up expected params for BuildingsStorage.GetBuildings
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Expect(ctx context.Context) *mBuildingsStorageMockGetBuildings {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsStorageMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingsStorageMockGetBuildingsExpectation{}
	}

	if mmGetBuildings.defaultExpectation.paramPtrs != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsStorageMock.GetBuildings mock is already set by ExpectParams functions")
	}

	mmGetBuildings.defaultExpectation.params = &BuildingsStorageMockGetBuildingsParams{ctx}
	for _, e := range mmGetBuildings.expectations {
		if minimock.Equal(e.params, mmGetBuildings.defaultExpectation.params) {
			mmGetBuildings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBuildings.defaultExpectation.params)
		}
	}

	return mmGetBuildings
}

// ExpectCtxParam1 sets up expected param ctx for BuildingsStorage.GetBuildings
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) ExpectCtxParam1(ctx context.Context) *mBuildingsStorageMockGetBuildings {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsStorageMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingsStorageMockGetBuildingsExpectation{}
	}

	if mmGetBuildings.defaultExpectation.params != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsStorageMock.GetBuildings mock is already set by Expect")
	}

	if mmGetBuildings.defaultExpectation.paramPtrs == nil {
		mmGetBuildings.defaultExpectation.paramPtrs = &BuildingsStorageMockGetBuildingsParamPtrs{}
	}
	mmGetBuildings.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBuildings
}

// Inspect accepts an inspector function that has same arguments as the BuildingsStorage.GetBuildings
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Inspect(f func(ctx context.Context)) *mBuildingsStorageMockGetBuildings {
	if mmGetBuildings.mock.inspectFuncGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("Inspect function is already set for BuildingsStorageMock.GetBuildings")
	}

	mmGetBuildings.mock.inspectFuncGetBuildings = f

	return mmGetBuildings
}

// Return sets up results that will be returned by BuildingsStorage.GetBuildings
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Return(b1 models.BuildingSlice, err error) *BuildingsStorageMock {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsStorageMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingsStorageMockGetBuildingsExpectation{mock: mmGetBuildings.mock}
	}
	mmGetBuildings.defaultExpectation.results = &BuildingsStorageMockGetBuildingsResults{b1, err}
	return mmGetBuildings.mock
}

// Set uses given function f to mock the BuildingsStorage.GetBuildings method
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Set(f func(ctx context.Context) (b1 models.BuildingSlice, err error)) *BuildingsStorageMock {
	if mmGetBuildings.defaultExpectation != nil {
		mmGetBuildings.mock.t.Fatalf("Default expectation is already set for the BuildingsStorage.GetBuildings method")
	}

	if len(mmGetBuildings.expectations) > 0 {
		mmGetBuildings.mock.t.Fatalf("Some expectations are already set for the BuildingsStorage.GetBuildings method")
	}

	mmGetBuildings.mock.funcGetBuildings = f
	return mmGetBuildings.mock
}

// When sets expectation for the BuildingsStorage.GetBuildings which will trigger the result defined by the following
// Then helper
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) When(ctx context.Context) *BuildingsStorageMockGetBuildingsExpectation {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingsStorageMock.GetBuildings mock is already set by Set")
	}

	expectation := &BuildingsStorageMockGetBuildingsExpectation{
		mock:   mmGetBuildings.mock,
		params: &BuildingsStorageMockGetBuildingsParams{ctx},
	}
	mmGetBuildings.expectations = append(mmGetBuildings.expectations, expectation)
	return expectation
}

// Then sets up BuildingsStorage.GetBuildings return parameters for the expectation previously defined by the When method
func (e *BuildingsStorageMockGetBuildingsExpectation) Then(b1 models.BuildingSlice, err error) *BuildingsStorageMock {
	e.results = &BuildingsStorageMockGetBuildingsResults{b1, err}
	return e.mock
}

// Times sets number of times BuildingsStorage.GetBuildings should be invoked
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Times(n uint64) *mBuildingsStorageMockGetBuildings {
	if n == 0 {
		mmGetBuildings.mock.t.Fatalf("Times of BuildingsStorageMock.GetBuildings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBuildings.expectedInvocations, n)
	return mmGetBuildings
}

func (mmGetBuildings *mBuildingsStorageMockGetBuildings) invocationsDone() bool {
	if len(mmGetBuildings.expectations) == 0 && mmGetBuildings.defaultExpectation == nil && mmGetBuildings.mock.funcGetBuildings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBuildings.mock.afterGetBuildingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBuildings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBuildings implements storage.BuildingsStorage
func (mmGetBuildings *BuildingsStorageMock) GetBuildings(ctx context.Context) (b1 models.BuildingSlice, err error) {
	mm_atomic.AddUint64(&mmGetBuildings.beforeGetBuildingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBuildings.afterGetBuildingsCounter, 1)

	if mmGetBuildings.inspectFuncGetBuildings != nil {
		mmGetBuildings.inspectFuncGetBuildings(ctx)
	}

	mm_params := BuildingsStorageMockGetBuildingsParams{ctx}

	// Record call args
	mmGetBuildings.GetBuildingsMock.mutex.Lock()
	mmGetBuildings.GetBuildingsMock.callArgs = append(mmGetBuildings.GetBuildingsMock.callArgs, &mm_params)
	mmGetBuildings.GetBuildingsMock.mutex.Unlock()

	for _, e := range mmGetBuildings.GetBuildingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmGetBuildings.GetBuildingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBuildings.GetBuildingsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBuildings.GetBuildingsMock.defaultExpectation.params
		mm_want_ptrs := mmGetBuildings.GetBuildingsMock.defaultExpectation.paramPtrs

		mm_got := BuildingsStorageMockGetBuildingsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBuildings.t.Errorf("BuildingsStorageMock.GetBuildings got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBuildings.t.Errorf("BuildingsStorageMock.GetBuildings got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBuildings.GetBuildingsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBuildings.t.Fatal("No results are set for the BuildingsStorageMock.GetBuildings")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmGetBuildings.funcGetBuildings != nil {
		return mmGetBuildings.funcGetBuildings(ctx)
	}
	mmGetBuildings.t.Fatalf("Unexpected call to BuildingsStorageMock.GetBuildings. %v", ctx)
	return
}

// GetBuildingsAfterCounter returns a count of finished BuildingsStorageMock.GetBuildings invocations
func (mmGetBuildings *BuildingsStorageMock) GetBuildingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuildings.afterGetBuildingsCounter)
}

// GetBuildingsBeforeCounter returns a count of BuildingsStorageMock.GetBuildings invocations
func (mmGetBuildings *BuildingsStorageMock) GetBuildingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuildings.beforeGetBuildingsCounter)
}

// Calls returns a list of arguments used in each call to BuildingsStorageMock.GetBuildings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBuildings *mBuildingsStorageMockGetBuildings) Calls() []*BuildingsStorageMockGetBuildingsParams {
	mmGetBuildings.mutex.RLock()

	argCopy := make([]*BuildingsStorageMockGetBuildingsParams, len(mmGetBuildings.callArgs))
	copy(argCopy, mmGetBuildings.callArgs)

	mmGetBuildings.mutex.RUnlock()

	return argCopy
}

// MinimockGetBuildingsDone returns true if the count of the GetBuildings invocations corresponds
// the number of defined expectations
func (m *BuildingsStorageMock) MinimockGetBuildingsDone() bool {
	if m.GetBuildingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBuildingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBuildingsMock.invocationsDone()
}

// MinimockGetBuildingsInspect logs each unmet expectation
func (m *BuildingsStorageMock) MinimockGetBuildingsInspect() {
	for _, e := range m.GetBuildingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingsStorageMock.GetBuildings with params: %#v", *e.params)
		}
	}

	afterGetBuildingsCounter := mm_atomic.LoadUint64(&m.afterGetBuildingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBuildingsMock.defaultExpectation != nil && afterGetBuildingsCounter < 1 {
		if m.GetBuildingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingsStorageMock.GetBuildings")
		} else {
			m.t.Errorf("Expected call to BuildingsStorageMock.GetBuildings with params: %#v", *m.GetBuildingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBuildings != nil && afterGetBuildingsCounter < 1 {
		m.t.Error("Expected call to BuildingsStorageMock.GetBuildings")
	}

	if !m.GetBuildingsMock.invocationsDone() && afterGetBuildingsCounter > 0 {
		m.t.Errorf("Expected %d calls to BuildingsStorageMock.GetBuildings but found %d calls",
			mm_atomic.LoadUint64(&m.GetBuildingsMock.expectedInvocations), afterGetBuildingsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BuildingsStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateBuildingInspect()

			m.MinimockDeleteBuildingInspect()

			m.MinimockGetBuildingInspect()

			m.MinimockGetBuildingsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BuildingsStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BuildingsStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBuildingDone() &&
		m.MinimockDeleteBuildingDone() &&
		m.MinimockGetBuildingDone() &&
		m.MinimockGetBuildingsDone()
}
