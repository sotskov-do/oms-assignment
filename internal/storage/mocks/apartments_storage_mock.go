// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sotskov-do/oms-assignment/internal/storage.ApartmentsStorage -o apartments_storage_mock_test.go -n ApartmentsStorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sotskov-do/oms-assignment/internal/models"
)

// ApartmentsStorageMock implements storage.ApartmentsStorage
type ApartmentsStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateApartment          func(ctx context.Context, apartment *models.Apartment) (err error)
	inspectFuncCreateApartment   func(ctx context.Context, apartment *models.Apartment)
	afterCreateApartmentCounter  uint64
	beforeCreateApartmentCounter uint64
	CreateApartmentMock          mApartmentsStorageMockCreateApartment

	funcDeleteApartment          func(ctx context.Context, id int) (i1 int64, err error)
	inspectFuncDeleteApartment   func(ctx context.Context, id int)
	afterDeleteApartmentCounter  uint64
	beforeDeleteApartmentCounter uint64
	DeleteApartmentMock          mApartmentsStorageMockDeleteApartment

	funcGetApartment          func(ctx context.Context, id int) (ap1 *models.Apartment, err error)
	inspectFuncGetApartment   func(ctx context.Context, id int)
	afterGetApartmentCounter  uint64
	beforeGetApartmentCounter uint64
	GetApartmentMock          mApartmentsStorageMockGetApartment

	funcGetApartments          func(ctx context.Context) (a1 models.ApartmentSlice, err error)
	inspectFuncGetApartments   func(ctx context.Context)
	afterGetApartmentsCounter  uint64
	beforeGetApartmentsCounter uint64
	GetApartmentsMock          mApartmentsStorageMockGetApartments

	funcGetApartmentsInBuilding          func(ctx context.Context, buildingId int) (a1 models.ApartmentSlice, err error)
	inspectFuncGetApartmentsInBuilding   func(ctx context.Context, buildingId int)
	afterGetApartmentsInBuildingCounter  uint64
	beforeGetApartmentsInBuildingCounter uint64
	GetApartmentsInBuildingMock          mApartmentsStorageMockGetApartmentsInBuilding
}

// NewApartmentsStorageMock returns a mock for storage.ApartmentsStorage
func NewApartmentsStorageMock(t minimock.Tester) *ApartmentsStorageMock {
	m := &ApartmentsStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateApartmentMock = mApartmentsStorageMockCreateApartment{mock: m}
	m.CreateApartmentMock.callArgs = []*ApartmentsStorageMockCreateApartmentParams{}

	m.DeleteApartmentMock = mApartmentsStorageMockDeleteApartment{mock: m}
	m.DeleteApartmentMock.callArgs = []*ApartmentsStorageMockDeleteApartmentParams{}

	m.GetApartmentMock = mApartmentsStorageMockGetApartment{mock: m}
	m.GetApartmentMock.callArgs = []*ApartmentsStorageMockGetApartmentParams{}

	m.GetApartmentsMock = mApartmentsStorageMockGetApartments{mock: m}
	m.GetApartmentsMock.callArgs = []*ApartmentsStorageMockGetApartmentsParams{}

	m.GetApartmentsInBuildingMock = mApartmentsStorageMockGetApartmentsInBuilding{mock: m}
	m.GetApartmentsInBuildingMock.callArgs = []*ApartmentsStorageMockGetApartmentsInBuildingParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mApartmentsStorageMockCreateApartment struct {
	optional           bool
	mock               *ApartmentsStorageMock
	defaultExpectation *ApartmentsStorageMockCreateApartmentExpectation
	expectations       []*ApartmentsStorageMockCreateApartmentExpectation

	callArgs []*ApartmentsStorageMockCreateApartmentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsStorageMockCreateApartmentExpectation specifies expectation struct of the ApartmentsStorage.CreateApartment
type ApartmentsStorageMockCreateApartmentExpectation struct {
	mock      *ApartmentsStorageMock
	params    *ApartmentsStorageMockCreateApartmentParams
	paramPtrs *ApartmentsStorageMockCreateApartmentParamPtrs
	results   *ApartmentsStorageMockCreateApartmentResults
	Counter   uint64
}

// ApartmentsStorageMockCreateApartmentParams contains parameters of the ApartmentsStorage.CreateApartment
type ApartmentsStorageMockCreateApartmentParams struct {
	ctx       context.Context
	apartment *models.Apartment
}

// ApartmentsStorageMockCreateApartmentParamPtrs contains pointers to parameters of the ApartmentsStorage.CreateApartment
type ApartmentsStorageMockCreateApartmentParamPtrs struct {
	ctx       *context.Context
	apartment **models.Apartment
}

// ApartmentsStorageMockCreateApartmentResults contains results of the ApartmentsStorage.CreateApartment
type ApartmentsStorageMockCreateApartmentResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Optional() *mApartmentsStorageMockCreateApartment {
	mmCreateApartment.optional = true
	return mmCreateApartment
}

// Expect sets up expected params for ApartmentsStorage.CreateApartment
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Expect(ctx context.Context, apartment *models.Apartment) *mApartmentsStorageMockCreateApartment {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsStorageMockCreateApartmentExpectation{}
	}

	if mmCreateApartment.defaultExpectation.paramPtrs != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by ExpectParams functions")
	}

	mmCreateApartment.defaultExpectation.params = &ApartmentsStorageMockCreateApartmentParams{ctx, apartment}
	for _, e := range mmCreateApartment.expectations {
		if minimock.Equal(e.params, mmCreateApartment.defaultExpectation.params) {
			mmCreateApartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateApartment.defaultExpectation.params)
		}
	}

	return mmCreateApartment
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsStorage.CreateApartment
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) ExpectCtxParam1(ctx context.Context) *mApartmentsStorageMockCreateApartment {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsStorageMockCreateApartmentExpectation{}
	}

	if mmCreateApartment.defaultExpectation.params != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Expect")
	}

	if mmCreateApartment.defaultExpectation.paramPtrs == nil {
		mmCreateApartment.defaultExpectation.paramPtrs = &ApartmentsStorageMockCreateApartmentParamPtrs{}
	}
	mmCreateApartment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateApartment
}

// ExpectApartmentParam2 sets up expected param apartment for ApartmentsStorage.CreateApartment
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) ExpectApartmentParam2(apartment *models.Apartment) *mApartmentsStorageMockCreateApartment {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsStorageMockCreateApartmentExpectation{}
	}

	if mmCreateApartment.defaultExpectation.params != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Expect")
	}

	if mmCreateApartment.defaultExpectation.paramPtrs == nil {
		mmCreateApartment.defaultExpectation.paramPtrs = &ApartmentsStorageMockCreateApartmentParamPtrs{}
	}
	mmCreateApartment.defaultExpectation.paramPtrs.apartment = &apartment

	return mmCreateApartment
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsStorage.CreateApartment
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Inspect(f func(ctx context.Context, apartment *models.Apartment)) *mApartmentsStorageMockCreateApartment {
	if mmCreateApartment.mock.inspectFuncCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("Inspect function is already set for ApartmentsStorageMock.CreateApartment")
	}

	mmCreateApartment.mock.inspectFuncCreateApartment = f

	return mmCreateApartment
}

// Return sets up results that will be returned by ApartmentsStorage.CreateApartment
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Return(err error) *ApartmentsStorageMock {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Set")
	}

	if mmCreateApartment.defaultExpectation == nil {
		mmCreateApartment.defaultExpectation = &ApartmentsStorageMockCreateApartmentExpectation{mock: mmCreateApartment.mock}
	}
	mmCreateApartment.defaultExpectation.results = &ApartmentsStorageMockCreateApartmentResults{err}
	return mmCreateApartment.mock
}

// Set uses given function f to mock the ApartmentsStorage.CreateApartment method
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Set(f func(ctx context.Context, apartment *models.Apartment) (err error)) *ApartmentsStorageMock {
	if mmCreateApartment.defaultExpectation != nil {
		mmCreateApartment.mock.t.Fatalf("Default expectation is already set for the ApartmentsStorage.CreateApartment method")
	}

	if len(mmCreateApartment.expectations) > 0 {
		mmCreateApartment.mock.t.Fatalf("Some expectations are already set for the ApartmentsStorage.CreateApartment method")
	}

	mmCreateApartment.mock.funcCreateApartment = f
	return mmCreateApartment.mock
}

// When sets expectation for the ApartmentsStorage.CreateApartment which will trigger the result defined by the following
// Then helper
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) When(ctx context.Context, apartment *models.Apartment) *ApartmentsStorageMockCreateApartmentExpectation {
	if mmCreateApartment.mock.funcCreateApartment != nil {
		mmCreateApartment.mock.t.Fatalf("ApartmentsStorageMock.CreateApartment mock is already set by Set")
	}

	expectation := &ApartmentsStorageMockCreateApartmentExpectation{
		mock:   mmCreateApartment.mock,
		params: &ApartmentsStorageMockCreateApartmentParams{ctx, apartment},
	}
	mmCreateApartment.expectations = append(mmCreateApartment.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsStorage.CreateApartment return parameters for the expectation previously defined by the When method
func (e *ApartmentsStorageMockCreateApartmentExpectation) Then(err error) *ApartmentsStorageMock {
	e.results = &ApartmentsStorageMockCreateApartmentResults{err}
	return e.mock
}

// Times sets number of times ApartmentsStorage.CreateApartment should be invoked
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Times(n uint64) *mApartmentsStorageMockCreateApartment {
	if n == 0 {
		mmCreateApartment.mock.t.Fatalf("Times of ApartmentsStorageMock.CreateApartment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateApartment.expectedInvocations, n)
	return mmCreateApartment
}

func (mmCreateApartment *mApartmentsStorageMockCreateApartment) invocationsDone() bool {
	if len(mmCreateApartment.expectations) == 0 && mmCreateApartment.defaultExpectation == nil && mmCreateApartment.mock.funcCreateApartment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateApartment.mock.afterCreateApartmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateApartment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateApartment implements storage.ApartmentsStorage
func (mmCreateApartment *ApartmentsStorageMock) CreateApartment(ctx context.Context, apartment *models.Apartment) (err error) {
	mm_atomic.AddUint64(&mmCreateApartment.beforeCreateApartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateApartment.afterCreateApartmentCounter, 1)

	if mmCreateApartment.inspectFuncCreateApartment != nil {
		mmCreateApartment.inspectFuncCreateApartment(ctx, apartment)
	}

	mm_params := ApartmentsStorageMockCreateApartmentParams{ctx, apartment}

	// Record call args
	mmCreateApartment.CreateApartmentMock.mutex.Lock()
	mmCreateApartment.CreateApartmentMock.callArgs = append(mmCreateApartment.CreateApartmentMock.callArgs, &mm_params)
	mmCreateApartment.CreateApartmentMock.mutex.Unlock()

	for _, e := range mmCreateApartment.CreateApartmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateApartment.CreateApartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateApartment.CreateApartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateApartment.CreateApartmentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateApartment.CreateApartmentMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsStorageMockCreateApartmentParams{ctx, apartment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateApartment.t.Errorf("ApartmentsStorageMock.CreateApartment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.apartment != nil && !minimock.Equal(*mm_want_ptrs.apartment, mm_got.apartment) {
				mmCreateApartment.t.Errorf("ApartmentsStorageMock.CreateApartment got unexpected parameter apartment, want: %#v, got: %#v%s\n", *mm_want_ptrs.apartment, mm_got.apartment, minimock.Diff(*mm_want_ptrs.apartment, mm_got.apartment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateApartment.t.Errorf("ApartmentsStorageMock.CreateApartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateApartment.CreateApartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateApartment.t.Fatal("No results are set for the ApartmentsStorageMock.CreateApartment")
		}
		return (*mm_results).err
	}
	if mmCreateApartment.funcCreateApartment != nil {
		return mmCreateApartment.funcCreateApartment(ctx, apartment)
	}
	mmCreateApartment.t.Fatalf("Unexpected call to ApartmentsStorageMock.CreateApartment. %v %v", ctx, apartment)
	return
}

// CreateApartmentAfterCounter returns a count of finished ApartmentsStorageMock.CreateApartment invocations
func (mmCreateApartment *ApartmentsStorageMock) CreateApartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApartment.afterCreateApartmentCounter)
}

// CreateApartmentBeforeCounter returns a count of ApartmentsStorageMock.CreateApartment invocations
func (mmCreateApartment *ApartmentsStorageMock) CreateApartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApartment.beforeCreateApartmentCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsStorageMock.CreateApartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateApartment *mApartmentsStorageMockCreateApartment) Calls() []*ApartmentsStorageMockCreateApartmentParams {
	mmCreateApartment.mutex.RLock()

	argCopy := make([]*ApartmentsStorageMockCreateApartmentParams, len(mmCreateApartment.callArgs))
	copy(argCopy, mmCreateApartment.callArgs)

	mmCreateApartment.mutex.RUnlock()

	return argCopy
}

// MinimockCreateApartmentDone returns true if the count of the CreateApartment invocations corresponds
// the number of defined expectations
func (m *ApartmentsStorageMock) MinimockCreateApartmentDone() bool {
	if m.CreateApartmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateApartmentMock.invocationsDone()
}

// MinimockCreateApartmentInspect logs each unmet expectation
func (m *ApartmentsStorageMock) MinimockCreateApartmentInspect() {
	for _, e := range m.CreateApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsStorageMock.CreateApartment with params: %#v", *e.params)
		}
	}

	afterCreateApartmentCounter := mm_atomic.LoadUint64(&m.afterCreateApartmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateApartmentMock.defaultExpectation != nil && afterCreateApartmentCounter < 1 {
		if m.CreateApartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsStorageMock.CreateApartment")
		} else {
			m.t.Errorf("Expected call to ApartmentsStorageMock.CreateApartment with params: %#v", *m.CreateApartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateApartment != nil && afterCreateApartmentCounter < 1 {
		m.t.Error("Expected call to ApartmentsStorageMock.CreateApartment")
	}

	if !m.CreateApartmentMock.invocationsDone() && afterCreateApartmentCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsStorageMock.CreateApartment but found %d calls",
			mm_atomic.LoadUint64(&m.CreateApartmentMock.expectedInvocations), afterCreateApartmentCounter)
	}
}

type mApartmentsStorageMockDeleteApartment struct {
	optional           bool
	mock               *ApartmentsStorageMock
	defaultExpectation *ApartmentsStorageMockDeleteApartmentExpectation
	expectations       []*ApartmentsStorageMockDeleteApartmentExpectation

	callArgs []*ApartmentsStorageMockDeleteApartmentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsStorageMockDeleteApartmentExpectation specifies expectation struct of the ApartmentsStorage.DeleteApartment
type ApartmentsStorageMockDeleteApartmentExpectation struct {
	mock      *ApartmentsStorageMock
	params    *ApartmentsStorageMockDeleteApartmentParams
	paramPtrs *ApartmentsStorageMockDeleteApartmentParamPtrs
	results   *ApartmentsStorageMockDeleteApartmentResults
	Counter   uint64
}

// ApartmentsStorageMockDeleteApartmentParams contains parameters of the ApartmentsStorage.DeleteApartment
type ApartmentsStorageMockDeleteApartmentParams struct {
	ctx context.Context
	id  int
}

// ApartmentsStorageMockDeleteApartmentParamPtrs contains pointers to parameters of the ApartmentsStorage.DeleteApartment
type ApartmentsStorageMockDeleteApartmentParamPtrs struct {
	ctx *context.Context
	id  *int
}

// ApartmentsStorageMockDeleteApartmentResults contains results of the ApartmentsStorage.DeleteApartment
type ApartmentsStorageMockDeleteApartmentResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Optional() *mApartmentsStorageMockDeleteApartment {
	mmDeleteApartment.optional = true
	return mmDeleteApartment
}

// Expect sets up expected params for ApartmentsStorage.DeleteApartment
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Expect(ctx context.Context, id int) *mApartmentsStorageMockDeleteApartment {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsStorageMockDeleteApartmentExpectation{}
	}

	if mmDeleteApartment.defaultExpectation.paramPtrs != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by ExpectParams functions")
	}

	mmDeleteApartment.defaultExpectation.params = &ApartmentsStorageMockDeleteApartmentParams{ctx, id}
	for _, e := range mmDeleteApartment.expectations {
		if minimock.Equal(e.params, mmDeleteApartment.defaultExpectation.params) {
			mmDeleteApartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteApartment.defaultExpectation.params)
		}
	}

	return mmDeleteApartment
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsStorage.DeleteApartment
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) ExpectCtxParam1(ctx context.Context) *mApartmentsStorageMockDeleteApartment {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsStorageMockDeleteApartmentExpectation{}
	}

	if mmDeleteApartment.defaultExpectation.params != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Expect")
	}

	if mmDeleteApartment.defaultExpectation.paramPtrs == nil {
		mmDeleteApartment.defaultExpectation.paramPtrs = &ApartmentsStorageMockDeleteApartmentParamPtrs{}
	}
	mmDeleteApartment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteApartment
}

// ExpectIdParam2 sets up expected param id for ApartmentsStorage.DeleteApartment
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) ExpectIdParam2(id int) *mApartmentsStorageMockDeleteApartment {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsStorageMockDeleteApartmentExpectation{}
	}

	if mmDeleteApartment.defaultExpectation.params != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Expect")
	}

	if mmDeleteApartment.defaultExpectation.paramPtrs == nil {
		mmDeleteApartment.defaultExpectation.paramPtrs = &ApartmentsStorageMockDeleteApartmentParamPtrs{}
	}
	mmDeleteApartment.defaultExpectation.paramPtrs.id = &id

	return mmDeleteApartment
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsStorage.DeleteApartment
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Inspect(f func(ctx context.Context, id int)) *mApartmentsStorageMockDeleteApartment {
	if mmDeleteApartment.mock.inspectFuncDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("Inspect function is already set for ApartmentsStorageMock.DeleteApartment")
	}

	mmDeleteApartment.mock.inspectFuncDeleteApartment = f

	return mmDeleteApartment
}

// Return sets up results that will be returned by ApartmentsStorage.DeleteApartment
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Return(i1 int64, err error) *ApartmentsStorageMock {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Set")
	}

	if mmDeleteApartment.defaultExpectation == nil {
		mmDeleteApartment.defaultExpectation = &ApartmentsStorageMockDeleteApartmentExpectation{mock: mmDeleteApartment.mock}
	}
	mmDeleteApartment.defaultExpectation.results = &ApartmentsStorageMockDeleteApartmentResults{i1, err}
	return mmDeleteApartment.mock
}

// Set uses given function f to mock the ApartmentsStorage.DeleteApartment method
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Set(f func(ctx context.Context, id int) (i1 int64, err error)) *ApartmentsStorageMock {
	if mmDeleteApartment.defaultExpectation != nil {
		mmDeleteApartment.mock.t.Fatalf("Default expectation is already set for the ApartmentsStorage.DeleteApartment method")
	}

	if len(mmDeleteApartment.expectations) > 0 {
		mmDeleteApartment.mock.t.Fatalf("Some expectations are already set for the ApartmentsStorage.DeleteApartment method")
	}

	mmDeleteApartment.mock.funcDeleteApartment = f
	return mmDeleteApartment.mock
}

// When sets expectation for the ApartmentsStorage.DeleteApartment which will trigger the result defined by the following
// Then helper
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) When(ctx context.Context, id int) *ApartmentsStorageMockDeleteApartmentExpectation {
	if mmDeleteApartment.mock.funcDeleteApartment != nil {
		mmDeleteApartment.mock.t.Fatalf("ApartmentsStorageMock.DeleteApartment mock is already set by Set")
	}

	expectation := &ApartmentsStorageMockDeleteApartmentExpectation{
		mock:   mmDeleteApartment.mock,
		params: &ApartmentsStorageMockDeleteApartmentParams{ctx, id},
	}
	mmDeleteApartment.expectations = append(mmDeleteApartment.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsStorage.DeleteApartment return parameters for the expectation previously defined by the When method
func (e *ApartmentsStorageMockDeleteApartmentExpectation) Then(i1 int64, err error) *ApartmentsStorageMock {
	e.results = &ApartmentsStorageMockDeleteApartmentResults{i1, err}
	return e.mock
}

// Times sets number of times ApartmentsStorage.DeleteApartment should be invoked
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Times(n uint64) *mApartmentsStorageMockDeleteApartment {
	if n == 0 {
		mmDeleteApartment.mock.t.Fatalf("Times of ApartmentsStorageMock.DeleteApartment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteApartment.expectedInvocations, n)
	return mmDeleteApartment
}

func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) invocationsDone() bool {
	if len(mmDeleteApartment.expectations) == 0 && mmDeleteApartment.defaultExpectation == nil && mmDeleteApartment.mock.funcDeleteApartment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteApartment.mock.afterDeleteApartmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteApartment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteApartment implements storage.ApartmentsStorage
func (mmDeleteApartment *ApartmentsStorageMock) DeleteApartment(ctx context.Context, id int) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDeleteApartment.beforeDeleteApartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteApartment.afterDeleteApartmentCounter, 1)

	if mmDeleteApartment.inspectFuncDeleteApartment != nil {
		mmDeleteApartment.inspectFuncDeleteApartment(ctx, id)
	}

	mm_params := ApartmentsStorageMockDeleteApartmentParams{ctx, id}

	// Record call args
	mmDeleteApartment.DeleteApartmentMock.mutex.Lock()
	mmDeleteApartment.DeleteApartmentMock.callArgs = append(mmDeleteApartment.DeleteApartmentMock.callArgs, &mm_params)
	mmDeleteApartment.DeleteApartmentMock.mutex.Unlock()

	for _, e := range mmDeleteApartment.DeleteApartmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDeleteApartment.DeleteApartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteApartment.DeleteApartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteApartment.DeleteApartmentMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteApartment.DeleteApartmentMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsStorageMockDeleteApartmentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteApartment.t.Errorf("ApartmentsStorageMock.DeleteApartment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteApartment.t.Errorf("ApartmentsStorageMock.DeleteApartment got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteApartment.t.Errorf("ApartmentsStorageMock.DeleteApartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteApartment.DeleteApartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteApartment.t.Fatal("No results are set for the ApartmentsStorageMock.DeleteApartment")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDeleteApartment.funcDeleteApartment != nil {
		return mmDeleteApartment.funcDeleteApartment(ctx, id)
	}
	mmDeleteApartment.t.Fatalf("Unexpected call to ApartmentsStorageMock.DeleteApartment. %v %v", ctx, id)
	return
}

// DeleteApartmentAfterCounter returns a count of finished ApartmentsStorageMock.DeleteApartment invocations
func (mmDeleteApartment *ApartmentsStorageMock) DeleteApartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApartment.afterDeleteApartmentCounter)
}

// DeleteApartmentBeforeCounter returns a count of ApartmentsStorageMock.DeleteApartment invocations
func (mmDeleteApartment *ApartmentsStorageMock) DeleteApartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApartment.beforeDeleteApartmentCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsStorageMock.DeleteApartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteApartment *mApartmentsStorageMockDeleteApartment) Calls() []*ApartmentsStorageMockDeleteApartmentParams {
	mmDeleteApartment.mutex.RLock()

	argCopy := make([]*ApartmentsStorageMockDeleteApartmentParams, len(mmDeleteApartment.callArgs))
	copy(argCopy, mmDeleteApartment.callArgs)

	mmDeleteApartment.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteApartmentDone returns true if the count of the DeleteApartment invocations corresponds
// the number of defined expectations
func (m *ApartmentsStorageMock) MinimockDeleteApartmentDone() bool {
	if m.DeleteApartmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteApartmentMock.invocationsDone()
}

// MinimockDeleteApartmentInspect logs each unmet expectation
func (m *ApartmentsStorageMock) MinimockDeleteApartmentInspect() {
	for _, e := range m.DeleteApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsStorageMock.DeleteApartment with params: %#v", *e.params)
		}
	}

	afterDeleteApartmentCounter := mm_atomic.LoadUint64(&m.afterDeleteApartmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteApartmentMock.defaultExpectation != nil && afterDeleteApartmentCounter < 1 {
		if m.DeleteApartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsStorageMock.DeleteApartment")
		} else {
			m.t.Errorf("Expected call to ApartmentsStorageMock.DeleteApartment with params: %#v", *m.DeleteApartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteApartment != nil && afterDeleteApartmentCounter < 1 {
		m.t.Error("Expected call to ApartmentsStorageMock.DeleteApartment")
	}

	if !m.DeleteApartmentMock.invocationsDone() && afterDeleteApartmentCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsStorageMock.DeleteApartment but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteApartmentMock.expectedInvocations), afterDeleteApartmentCounter)
	}
}

type mApartmentsStorageMockGetApartment struct {
	optional           bool
	mock               *ApartmentsStorageMock
	defaultExpectation *ApartmentsStorageMockGetApartmentExpectation
	expectations       []*ApartmentsStorageMockGetApartmentExpectation

	callArgs []*ApartmentsStorageMockGetApartmentParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsStorageMockGetApartmentExpectation specifies expectation struct of the ApartmentsStorage.GetApartment
type ApartmentsStorageMockGetApartmentExpectation struct {
	mock      *ApartmentsStorageMock
	params    *ApartmentsStorageMockGetApartmentParams
	paramPtrs *ApartmentsStorageMockGetApartmentParamPtrs
	results   *ApartmentsStorageMockGetApartmentResults
	Counter   uint64
}

// ApartmentsStorageMockGetApartmentParams contains parameters of the ApartmentsStorage.GetApartment
type ApartmentsStorageMockGetApartmentParams struct {
	ctx context.Context
	id  int
}

// ApartmentsStorageMockGetApartmentParamPtrs contains pointers to parameters of the ApartmentsStorage.GetApartment
type ApartmentsStorageMockGetApartmentParamPtrs struct {
	ctx *context.Context
	id  *int
}

// ApartmentsStorageMockGetApartmentResults contains results of the ApartmentsStorage.GetApartment
type ApartmentsStorageMockGetApartmentResults struct {
	ap1 *models.Apartment
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApartment *mApartmentsStorageMockGetApartment) Optional() *mApartmentsStorageMockGetApartment {
	mmGetApartment.optional = true
	return mmGetApartment
}

// Expect sets up expected params for ApartmentsStorage.GetApartment
func (mmGetApartment *mApartmentsStorageMockGetApartment) Expect(ctx context.Context, id int) *mApartmentsStorageMockGetApartment {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsStorageMockGetApartmentExpectation{}
	}

	if mmGetApartment.defaultExpectation.paramPtrs != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by ExpectParams functions")
	}

	mmGetApartment.defaultExpectation.params = &ApartmentsStorageMockGetApartmentParams{ctx, id}
	for _, e := range mmGetApartment.expectations {
		if minimock.Equal(e.params, mmGetApartment.defaultExpectation.params) {
			mmGetApartment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApartment.defaultExpectation.params)
		}
	}

	return mmGetApartment
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsStorage.GetApartment
func (mmGetApartment *mApartmentsStorageMockGetApartment) ExpectCtxParam1(ctx context.Context) *mApartmentsStorageMockGetApartment {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsStorageMockGetApartmentExpectation{}
	}

	if mmGetApartment.defaultExpectation.params != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Expect")
	}

	if mmGetApartment.defaultExpectation.paramPtrs == nil {
		mmGetApartment.defaultExpectation.paramPtrs = &ApartmentsStorageMockGetApartmentParamPtrs{}
	}
	mmGetApartment.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApartment
}

// ExpectIdParam2 sets up expected param id for ApartmentsStorage.GetApartment
func (mmGetApartment *mApartmentsStorageMockGetApartment) ExpectIdParam2(id int) *mApartmentsStorageMockGetApartment {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsStorageMockGetApartmentExpectation{}
	}

	if mmGetApartment.defaultExpectation.params != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Expect")
	}

	if mmGetApartment.defaultExpectation.paramPtrs == nil {
		mmGetApartment.defaultExpectation.paramPtrs = &ApartmentsStorageMockGetApartmentParamPtrs{}
	}
	mmGetApartment.defaultExpectation.paramPtrs.id = &id

	return mmGetApartment
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsStorage.GetApartment
func (mmGetApartment *mApartmentsStorageMockGetApartment) Inspect(f func(ctx context.Context, id int)) *mApartmentsStorageMockGetApartment {
	if mmGetApartment.mock.inspectFuncGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("Inspect function is already set for ApartmentsStorageMock.GetApartment")
	}

	mmGetApartment.mock.inspectFuncGetApartment = f

	return mmGetApartment
}

// Return sets up results that will be returned by ApartmentsStorage.GetApartment
func (mmGetApartment *mApartmentsStorageMockGetApartment) Return(ap1 *models.Apartment, err error) *ApartmentsStorageMock {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Set")
	}

	if mmGetApartment.defaultExpectation == nil {
		mmGetApartment.defaultExpectation = &ApartmentsStorageMockGetApartmentExpectation{mock: mmGetApartment.mock}
	}
	mmGetApartment.defaultExpectation.results = &ApartmentsStorageMockGetApartmentResults{ap1, err}
	return mmGetApartment.mock
}

// Set uses given function f to mock the ApartmentsStorage.GetApartment method
func (mmGetApartment *mApartmentsStorageMockGetApartment) Set(f func(ctx context.Context, id int) (ap1 *models.Apartment, err error)) *ApartmentsStorageMock {
	if mmGetApartment.defaultExpectation != nil {
		mmGetApartment.mock.t.Fatalf("Default expectation is already set for the ApartmentsStorage.GetApartment method")
	}

	if len(mmGetApartment.expectations) > 0 {
		mmGetApartment.mock.t.Fatalf("Some expectations are already set for the ApartmentsStorage.GetApartment method")
	}

	mmGetApartment.mock.funcGetApartment = f
	return mmGetApartment.mock
}

// When sets expectation for the ApartmentsStorage.GetApartment which will trigger the result defined by the following
// Then helper
func (mmGetApartment *mApartmentsStorageMockGetApartment) When(ctx context.Context, id int) *ApartmentsStorageMockGetApartmentExpectation {
	if mmGetApartment.mock.funcGetApartment != nil {
		mmGetApartment.mock.t.Fatalf("ApartmentsStorageMock.GetApartment mock is already set by Set")
	}

	expectation := &ApartmentsStorageMockGetApartmentExpectation{
		mock:   mmGetApartment.mock,
		params: &ApartmentsStorageMockGetApartmentParams{ctx, id},
	}
	mmGetApartment.expectations = append(mmGetApartment.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsStorage.GetApartment return parameters for the expectation previously defined by the When method
func (e *ApartmentsStorageMockGetApartmentExpectation) Then(ap1 *models.Apartment, err error) *ApartmentsStorageMock {
	e.results = &ApartmentsStorageMockGetApartmentResults{ap1, err}
	return e.mock
}

// Times sets number of times ApartmentsStorage.GetApartment should be invoked
func (mmGetApartment *mApartmentsStorageMockGetApartment) Times(n uint64) *mApartmentsStorageMockGetApartment {
	if n == 0 {
		mmGetApartment.mock.t.Fatalf("Times of ApartmentsStorageMock.GetApartment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApartment.expectedInvocations, n)
	return mmGetApartment
}

func (mmGetApartment *mApartmentsStorageMockGetApartment) invocationsDone() bool {
	if len(mmGetApartment.expectations) == 0 && mmGetApartment.defaultExpectation == nil && mmGetApartment.mock.funcGetApartment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApartment.mock.afterGetApartmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApartment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApartment implements storage.ApartmentsStorage
func (mmGetApartment *ApartmentsStorageMock) GetApartment(ctx context.Context, id int) (ap1 *models.Apartment, err error) {
	mm_atomic.AddUint64(&mmGetApartment.beforeGetApartmentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApartment.afterGetApartmentCounter, 1)

	if mmGetApartment.inspectFuncGetApartment != nil {
		mmGetApartment.inspectFuncGetApartment(ctx, id)
	}

	mm_params := ApartmentsStorageMockGetApartmentParams{ctx, id}

	// Record call args
	mmGetApartment.GetApartmentMock.mutex.Lock()
	mmGetApartment.GetApartmentMock.callArgs = append(mmGetApartment.GetApartmentMock.callArgs, &mm_params)
	mmGetApartment.GetApartmentMock.mutex.Unlock()

	for _, e := range mmGetApartment.GetApartmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApartment.GetApartmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApartment.GetApartmentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApartment.GetApartmentMock.defaultExpectation.params
		mm_want_ptrs := mmGetApartment.GetApartmentMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsStorageMockGetApartmentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApartment.t.Errorf("ApartmentsStorageMock.GetApartment got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetApartment.t.Errorf("ApartmentsStorageMock.GetApartment got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApartment.t.Errorf("ApartmentsStorageMock.GetApartment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApartment.GetApartmentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApartment.t.Fatal("No results are set for the ApartmentsStorageMock.GetApartment")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApartment.funcGetApartment != nil {
		return mmGetApartment.funcGetApartment(ctx, id)
	}
	mmGetApartment.t.Fatalf("Unexpected call to ApartmentsStorageMock.GetApartment. %v %v", ctx, id)
	return
}

// GetApartmentAfterCounter returns a count of finished ApartmentsStorageMock.GetApartment invocations
func (mmGetApartment *ApartmentsStorageMock) GetApartmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartment.afterGetApartmentCounter)
}

// GetApartmentBeforeCounter returns a count of ApartmentsStorageMock.GetApartment invocations
func (mmGetApartment *ApartmentsStorageMock) GetApartmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartment.beforeGetApartmentCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsStorageMock.GetApartment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApartment *mApartmentsStorageMockGetApartment) Calls() []*ApartmentsStorageMockGetApartmentParams {
	mmGetApartment.mutex.RLock()

	argCopy := make([]*ApartmentsStorageMockGetApartmentParams, len(mmGetApartment.callArgs))
	copy(argCopy, mmGetApartment.callArgs)

	mmGetApartment.mutex.RUnlock()

	return argCopy
}

// MinimockGetApartmentDone returns true if the count of the GetApartment invocations corresponds
// the number of defined expectations
func (m *ApartmentsStorageMock) MinimockGetApartmentDone() bool {
	if m.GetApartmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApartmentMock.invocationsDone()
}

// MinimockGetApartmentInspect logs each unmet expectation
func (m *ApartmentsStorageMock) MinimockGetApartmentInspect() {
	for _, e := range m.GetApartmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsStorageMock.GetApartment with params: %#v", *e.params)
		}
	}

	afterGetApartmentCounter := mm_atomic.LoadUint64(&m.afterGetApartmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApartmentMock.defaultExpectation != nil && afterGetApartmentCounter < 1 {
		if m.GetApartmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsStorageMock.GetApartment")
		} else {
			m.t.Errorf("Expected call to ApartmentsStorageMock.GetApartment with params: %#v", *m.GetApartmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApartment != nil && afterGetApartmentCounter < 1 {
		m.t.Error("Expected call to ApartmentsStorageMock.GetApartment")
	}

	if !m.GetApartmentMock.invocationsDone() && afterGetApartmentCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsStorageMock.GetApartment but found %d calls",
			mm_atomic.LoadUint64(&m.GetApartmentMock.expectedInvocations), afterGetApartmentCounter)
	}
}

type mApartmentsStorageMockGetApartments struct {
	optional           bool
	mock               *ApartmentsStorageMock
	defaultExpectation *ApartmentsStorageMockGetApartmentsExpectation
	expectations       []*ApartmentsStorageMockGetApartmentsExpectation

	callArgs []*ApartmentsStorageMockGetApartmentsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsStorageMockGetApartmentsExpectation specifies expectation struct of the ApartmentsStorage.GetApartments
type ApartmentsStorageMockGetApartmentsExpectation struct {
	mock      *ApartmentsStorageMock
	params    *ApartmentsStorageMockGetApartmentsParams
	paramPtrs *ApartmentsStorageMockGetApartmentsParamPtrs
	results   *ApartmentsStorageMockGetApartmentsResults
	Counter   uint64
}

// ApartmentsStorageMockGetApartmentsParams contains parameters of the ApartmentsStorage.GetApartments
type ApartmentsStorageMockGetApartmentsParams struct {
	ctx context.Context
}

// ApartmentsStorageMockGetApartmentsParamPtrs contains pointers to parameters of the ApartmentsStorage.GetApartments
type ApartmentsStorageMockGetApartmentsParamPtrs struct {
	ctx *context.Context
}

// ApartmentsStorageMockGetApartmentsResults contains results of the ApartmentsStorage.GetApartments
type ApartmentsStorageMockGetApartmentsResults struct {
	a1  models.ApartmentSlice
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApartments *mApartmentsStorageMockGetApartments) Optional() *mApartmentsStorageMockGetApartments {
	mmGetApartments.optional = true
	return mmGetApartments
}

// Expect sets up expected params for ApartmentsStorage.GetApartments
func (mmGetApartments *mApartmentsStorageMockGetApartments) Expect(ctx context.Context) *mApartmentsStorageMockGetApartments {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsStorageMock.GetApartments mock is already set by Set")
	}

	if mmGetApartments.defaultExpectation == nil {
		mmGetApartments.defaultExpectation = &ApartmentsStorageMockGetApartmentsExpectation{}
	}

	if mmGetApartments.defaultExpectation.paramPtrs != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsStorageMock.GetApartments mock is already set by ExpectParams functions")
	}

	mmGetApartments.defaultExpectation.params = &ApartmentsStorageMockGetApartmentsParams{ctx}
	for _, e := range mmGetApartments.expectations {
		if minimock.Equal(e.params, mmGetApartments.defaultExpectation.params) {
			mmGetApartments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApartments.defaultExpectation.params)
		}
	}

	return mmGetApartments
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsStorage.GetApartments
func (mmGetApartments *mApartmentsStorageMockGetApartments) ExpectCtxParam1(ctx context.Context) *mApartmentsStorageMockGetApartments {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsStorageMock.GetApartments mock is already set by Set")
	}

	if mmGetApartments.defaultExpectation == nil {
		mmGetApartments.defaultExpectation = &ApartmentsStorageMockGetApartmentsExpectation{}
	}

	if mmGetApartments.defaultExpectation.params != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsStorageMock.GetApartments mock is already set by Expect")
	}

	if mmGetApartments.defaultExpectation.paramPtrs == nil {
		mmGetApartments.defaultExpectation.paramPtrs = &ApartmentsStorageMockGetApartmentsParamPtrs{}
	}
	mmGetApartments.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApartments
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsStorage.GetApartments
func (mmGetApartments *mApartmentsStorageMockGetApartments) Inspect(f func(ctx context.Context)) *mApartmentsStorageMockGetApartments {
	if mmGetApartments.mock.inspectFuncGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("Inspect function is already set for ApartmentsStorageMock.GetApartments")
	}

	mmGetApartments.mock.inspectFuncGetApartments = f

	return mmGetApartments
}

// Return sets up results that will be returned by ApartmentsStorage.GetApartments
func (mmGetApartments *mApartmentsStorageMockGetApartments) Return(a1 models.ApartmentSlice, err error) *ApartmentsStorageMock {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsStorageMock.GetApartments mock is already set by Set")
	}

	if mmGetApartments.defaultExpectation == nil {
		mmGetApartments.defaultExpectation = &ApartmentsStorageMockGetApartmentsExpectation{mock: mmGetApartments.mock}
	}
	mmGetApartments.defaultExpectation.results = &ApartmentsStorageMockGetApartmentsResults{a1, err}
	return mmGetApartments.mock
}

// Set uses given function f to mock the ApartmentsStorage.GetApartments method
func (mmGetApartments *mApartmentsStorageMockGetApartments) Set(f func(ctx context.Context) (a1 models.ApartmentSlice, err error)) *ApartmentsStorageMock {
	if mmGetApartments.defaultExpectation != nil {
		mmGetApartments.mock.t.Fatalf("Default expectation is already set for the ApartmentsStorage.GetApartments method")
	}

	if len(mmGetApartments.expectations) > 0 {
		mmGetApartments.mock.t.Fatalf("Some expectations are already set for the ApartmentsStorage.GetApartments method")
	}

	mmGetApartments.mock.funcGetApartments = f
	return mmGetApartments.mock
}

// When sets expectation for the ApartmentsStorage.GetApartments which will trigger the result defined by the following
// Then helper
func (mmGetApartments *mApartmentsStorageMockGetApartments) When(ctx context.Context) *ApartmentsStorageMockGetApartmentsExpectation {
	if mmGetApartments.mock.funcGetApartments != nil {
		mmGetApartments.mock.t.Fatalf("ApartmentsStorageMock.GetApartments mock is already set by Set")
	}

	expectation := &ApartmentsStorageMockGetApartmentsExpectation{
		mock:   mmGetApartments.mock,
		params: &ApartmentsStorageMockGetApartmentsParams{ctx},
	}
	mmGetApartments.expectations = append(mmGetApartments.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsStorage.GetApartments return parameters for the expectation previously defined by the When method
func (e *ApartmentsStorageMockGetApartmentsExpectation) Then(a1 models.ApartmentSlice, err error) *ApartmentsStorageMock {
	e.results = &ApartmentsStorageMockGetApartmentsResults{a1, err}
	return e.mock
}

// Times sets number of times ApartmentsStorage.GetApartments should be invoked
func (mmGetApartments *mApartmentsStorageMockGetApartments) Times(n uint64) *mApartmentsStorageMockGetApartments {
	if n == 0 {
		mmGetApartments.mock.t.Fatalf("Times of ApartmentsStorageMock.GetApartments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApartments.expectedInvocations, n)
	return mmGetApartments
}

func (mmGetApartments *mApartmentsStorageMockGetApartments) invocationsDone() bool {
	if len(mmGetApartments.expectations) == 0 && mmGetApartments.defaultExpectation == nil && mmGetApartments.mock.funcGetApartments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApartments.mock.afterGetApartmentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApartments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApartments implements storage.ApartmentsStorage
func (mmGetApartments *ApartmentsStorageMock) GetApartments(ctx context.Context) (a1 models.ApartmentSlice, err error) {
	mm_atomic.AddUint64(&mmGetApartments.beforeGetApartmentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApartments.afterGetApartmentsCounter, 1)

	if mmGetApartments.inspectFuncGetApartments != nil {
		mmGetApartments.inspectFuncGetApartments(ctx)
	}

	mm_params := ApartmentsStorageMockGetApartmentsParams{ctx}

	// Record call args
	mmGetApartments.GetApartmentsMock.mutex.Lock()
	mmGetApartments.GetApartmentsMock.callArgs = append(mmGetApartments.GetApartmentsMock.callArgs, &mm_params)
	mmGetApartments.GetApartmentsMock.mutex.Unlock()

	for _, e := range mmGetApartments.GetApartmentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGetApartments.GetApartmentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApartments.GetApartmentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApartments.GetApartmentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetApartments.GetApartmentsMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsStorageMockGetApartmentsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApartments.t.Errorf("ApartmentsStorageMock.GetApartments got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApartments.t.Errorf("ApartmentsStorageMock.GetApartments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApartments.GetApartmentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApartments.t.Fatal("No results are set for the ApartmentsStorageMock.GetApartments")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGetApartments.funcGetApartments != nil {
		return mmGetApartments.funcGetApartments(ctx)
	}
	mmGetApartments.t.Fatalf("Unexpected call to ApartmentsStorageMock.GetApartments. %v", ctx)
	return
}

// GetApartmentsAfterCounter returns a count of finished ApartmentsStorageMock.GetApartments invocations
func (mmGetApartments *ApartmentsStorageMock) GetApartmentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartments.afterGetApartmentsCounter)
}

// GetApartmentsBeforeCounter returns a count of ApartmentsStorageMock.GetApartments invocations
func (mmGetApartments *ApartmentsStorageMock) GetApartmentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartments.beforeGetApartmentsCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsStorageMock.GetApartments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApartments *mApartmentsStorageMockGetApartments) Calls() []*ApartmentsStorageMockGetApartmentsParams {
	mmGetApartments.mutex.RLock()

	argCopy := make([]*ApartmentsStorageMockGetApartmentsParams, len(mmGetApartments.callArgs))
	copy(argCopy, mmGetApartments.callArgs)

	mmGetApartments.mutex.RUnlock()

	return argCopy
}

// MinimockGetApartmentsDone returns true if the count of the GetApartments invocations corresponds
// the number of defined expectations
func (m *ApartmentsStorageMock) MinimockGetApartmentsDone() bool {
	if m.GetApartmentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApartmentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApartmentsMock.invocationsDone()
}

// MinimockGetApartmentsInspect logs each unmet expectation
func (m *ApartmentsStorageMock) MinimockGetApartmentsInspect() {
	for _, e := range m.GetApartmentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsStorageMock.GetApartments with params: %#v", *e.params)
		}
	}

	afterGetApartmentsCounter := mm_atomic.LoadUint64(&m.afterGetApartmentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApartmentsMock.defaultExpectation != nil && afterGetApartmentsCounter < 1 {
		if m.GetApartmentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsStorageMock.GetApartments")
		} else {
			m.t.Errorf("Expected call to ApartmentsStorageMock.GetApartments with params: %#v", *m.GetApartmentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApartments != nil && afterGetApartmentsCounter < 1 {
		m.t.Error("Expected call to ApartmentsStorageMock.GetApartments")
	}

	if !m.GetApartmentsMock.invocationsDone() && afterGetApartmentsCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsStorageMock.GetApartments but found %d calls",
			mm_atomic.LoadUint64(&m.GetApartmentsMock.expectedInvocations), afterGetApartmentsCounter)
	}
}

type mApartmentsStorageMockGetApartmentsInBuilding struct {
	optional           bool
	mock               *ApartmentsStorageMock
	defaultExpectation *ApartmentsStorageMockGetApartmentsInBuildingExpectation
	expectations       []*ApartmentsStorageMockGetApartmentsInBuildingExpectation

	callArgs []*ApartmentsStorageMockGetApartmentsInBuildingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ApartmentsStorageMockGetApartmentsInBuildingExpectation specifies expectation struct of the ApartmentsStorage.GetApartmentsInBuilding
type ApartmentsStorageMockGetApartmentsInBuildingExpectation struct {
	mock      *ApartmentsStorageMock
	params    *ApartmentsStorageMockGetApartmentsInBuildingParams
	paramPtrs *ApartmentsStorageMockGetApartmentsInBuildingParamPtrs
	results   *ApartmentsStorageMockGetApartmentsInBuildingResults
	Counter   uint64
}

// ApartmentsStorageMockGetApartmentsInBuildingParams contains parameters of the ApartmentsStorage.GetApartmentsInBuilding
type ApartmentsStorageMockGetApartmentsInBuildingParams struct {
	ctx        context.Context
	buildingId int
}

// ApartmentsStorageMockGetApartmentsInBuildingParamPtrs contains pointers to parameters of the ApartmentsStorage.GetApartmentsInBuilding
type ApartmentsStorageMockGetApartmentsInBuildingParamPtrs struct {
	ctx        *context.Context
	buildingId *int
}

// ApartmentsStorageMockGetApartmentsInBuildingResults contains results of the ApartmentsStorage.GetApartmentsInBuilding
type ApartmentsStorageMockGetApartmentsInBuildingResults struct {
	a1  models.ApartmentSlice
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Optional() *mApartmentsStorageMockGetApartmentsInBuilding {
	mmGetApartmentsInBuilding.optional = true
	return mmGetApartmentsInBuilding
}

// Expect sets up expected params for ApartmentsStorage.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Expect(ctx context.Context, buildingId int) *mApartmentsStorageMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsStorageMockGetApartmentsInBuildingExpectation{}
	}

	if mmGetApartmentsInBuilding.defaultExpectation.paramPtrs != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by ExpectParams functions")
	}

	mmGetApartmentsInBuilding.defaultExpectation.params = &ApartmentsStorageMockGetApartmentsInBuildingParams{ctx, buildingId}
	for _, e := range mmGetApartmentsInBuilding.expectations {
		if minimock.Equal(e.params, mmGetApartmentsInBuilding.defaultExpectation.params) {
			mmGetApartmentsInBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApartmentsInBuilding.defaultExpectation.params)
		}
	}

	return mmGetApartmentsInBuilding
}

// ExpectCtxParam1 sets up expected param ctx for ApartmentsStorage.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) ExpectCtxParam1(ctx context.Context) *mApartmentsStorageMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsStorageMockGetApartmentsInBuildingExpectation{}
	}

	if mmGetApartmentsInBuilding.defaultExpectation.params != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Expect")
	}

	if mmGetApartmentsInBuilding.defaultExpectation.paramPtrs == nil {
		mmGetApartmentsInBuilding.defaultExpectation.paramPtrs = &ApartmentsStorageMockGetApartmentsInBuildingParamPtrs{}
	}
	mmGetApartmentsInBuilding.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetApartmentsInBuilding
}

// ExpectBuildingIdParam2 sets up expected param buildingId for ApartmentsStorage.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) ExpectBuildingIdParam2(buildingId int) *mApartmentsStorageMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsStorageMockGetApartmentsInBuildingExpectation{}
	}

	if mmGetApartmentsInBuilding.defaultExpectation.params != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Expect")
	}

	if mmGetApartmentsInBuilding.defaultExpectation.paramPtrs == nil {
		mmGetApartmentsInBuilding.defaultExpectation.paramPtrs = &ApartmentsStorageMockGetApartmentsInBuildingParamPtrs{}
	}
	mmGetApartmentsInBuilding.defaultExpectation.paramPtrs.buildingId = &buildingId

	return mmGetApartmentsInBuilding
}

// Inspect accepts an inspector function that has same arguments as the ApartmentsStorage.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Inspect(f func(ctx context.Context, buildingId int)) *mApartmentsStorageMockGetApartmentsInBuilding {
	if mmGetApartmentsInBuilding.mock.inspectFuncGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Inspect function is already set for ApartmentsStorageMock.GetApartmentsInBuilding")
	}

	mmGetApartmentsInBuilding.mock.inspectFuncGetApartmentsInBuilding = f

	return mmGetApartmentsInBuilding
}

// Return sets up results that will be returned by ApartmentsStorage.GetApartmentsInBuilding
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Return(a1 models.ApartmentSlice, err error) *ApartmentsStorageMock {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Set")
	}

	if mmGetApartmentsInBuilding.defaultExpectation == nil {
		mmGetApartmentsInBuilding.defaultExpectation = &ApartmentsStorageMockGetApartmentsInBuildingExpectation{mock: mmGetApartmentsInBuilding.mock}
	}
	mmGetApartmentsInBuilding.defaultExpectation.results = &ApartmentsStorageMockGetApartmentsInBuildingResults{a1, err}
	return mmGetApartmentsInBuilding.mock
}

// Set uses given function f to mock the ApartmentsStorage.GetApartmentsInBuilding method
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Set(f func(ctx context.Context, buildingId int) (a1 models.ApartmentSlice, err error)) *ApartmentsStorageMock {
	if mmGetApartmentsInBuilding.defaultExpectation != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Default expectation is already set for the ApartmentsStorage.GetApartmentsInBuilding method")
	}

	if len(mmGetApartmentsInBuilding.expectations) > 0 {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Some expectations are already set for the ApartmentsStorage.GetApartmentsInBuilding method")
	}

	mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding = f
	return mmGetApartmentsInBuilding.mock
}

// When sets expectation for the ApartmentsStorage.GetApartmentsInBuilding which will trigger the result defined by the following
// Then helper
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) When(ctx context.Context, buildingId int) *ApartmentsStorageMockGetApartmentsInBuildingExpectation {
	if mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.mock.t.Fatalf("ApartmentsStorageMock.GetApartmentsInBuilding mock is already set by Set")
	}

	expectation := &ApartmentsStorageMockGetApartmentsInBuildingExpectation{
		mock:   mmGetApartmentsInBuilding.mock,
		params: &ApartmentsStorageMockGetApartmentsInBuildingParams{ctx, buildingId},
	}
	mmGetApartmentsInBuilding.expectations = append(mmGetApartmentsInBuilding.expectations, expectation)
	return expectation
}

// Then sets up ApartmentsStorage.GetApartmentsInBuilding return parameters for the expectation previously defined by the When method
func (e *ApartmentsStorageMockGetApartmentsInBuildingExpectation) Then(a1 models.ApartmentSlice, err error) *ApartmentsStorageMock {
	e.results = &ApartmentsStorageMockGetApartmentsInBuildingResults{a1, err}
	return e.mock
}

// Times sets number of times ApartmentsStorage.GetApartmentsInBuilding should be invoked
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Times(n uint64) *mApartmentsStorageMockGetApartmentsInBuilding {
	if n == 0 {
		mmGetApartmentsInBuilding.mock.t.Fatalf("Times of ApartmentsStorageMock.GetApartmentsInBuilding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApartmentsInBuilding.expectedInvocations, n)
	return mmGetApartmentsInBuilding
}

func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) invocationsDone() bool {
	if len(mmGetApartmentsInBuilding.expectations) == 0 && mmGetApartmentsInBuilding.defaultExpectation == nil && mmGetApartmentsInBuilding.mock.funcGetApartmentsInBuilding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.mock.afterGetApartmentsInBuildingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApartmentsInBuilding implements storage.ApartmentsStorage
func (mmGetApartmentsInBuilding *ApartmentsStorageMock) GetApartmentsInBuilding(ctx context.Context, buildingId int) (a1 models.ApartmentSlice, err error) {
	mm_atomic.AddUint64(&mmGetApartmentsInBuilding.beforeGetApartmentsInBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApartmentsInBuilding.afterGetApartmentsInBuildingCounter, 1)

	if mmGetApartmentsInBuilding.inspectFuncGetApartmentsInBuilding != nil {
		mmGetApartmentsInBuilding.inspectFuncGetApartmentsInBuilding(ctx, buildingId)
	}

	mm_params := ApartmentsStorageMockGetApartmentsInBuildingParams{ctx, buildingId}

	// Record call args
	mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.mutex.Lock()
	mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.callArgs = append(mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.callArgs, &mm_params)
	mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.mutex.Unlock()

	for _, e := range mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.params
		mm_want_ptrs := mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.paramPtrs

		mm_got := ApartmentsStorageMockGetApartmentsInBuildingParams{ctx, buildingId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApartmentsInBuilding.t.Errorf("ApartmentsStorageMock.GetApartmentsInBuilding got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.buildingId != nil && !minimock.Equal(*mm_want_ptrs.buildingId, mm_got.buildingId) {
				mmGetApartmentsInBuilding.t.Errorf("ApartmentsStorageMock.GetApartmentsInBuilding got unexpected parameter buildingId, want: %#v, got: %#v%s\n", *mm_want_ptrs.buildingId, mm_got.buildingId, minimock.Diff(*mm_want_ptrs.buildingId, mm_got.buildingId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApartmentsInBuilding.t.Errorf("ApartmentsStorageMock.GetApartmentsInBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApartmentsInBuilding.GetApartmentsInBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApartmentsInBuilding.t.Fatal("No results are set for the ApartmentsStorageMock.GetApartmentsInBuilding")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGetApartmentsInBuilding.funcGetApartmentsInBuilding != nil {
		return mmGetApartmentsInBuilding.funcGetApartmentsInBuilding(ctx, buildingId)
	}
	mmGetApartmentsInBuilding.t.Fatalf("Unexpected call to ApartmentsStorageMock.GetApartmentsInBuilding. %v %v", ctx, buildingId)
	return
}

// GetApartmentsInBuildingAfterCounter returns a count of finished ApartmentsStorageMock.GetApartmentsInBuilding invocations
func (mmGetApartmentsInBuilding *ApartmentsStorageMock) GetApartmentsInBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.afterGetApartmentsInBuildingCounter)
}

// GetApartmentsInBuildingBeforeCounter returns a count of ApartmentsStorageMock.GetApartmentsInBuilding invocations
func (mmGetApartmentsInBuilding *ApartmentsStorageMock) GetApartmentsInBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApartmentsInBuilding.beforeGetApartmentsInBuildingCounter)
}

// Calls returns a list of arguments used in each call to ApartmentsStorageMock.GetApartmentsInBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApartmentsInBuilding *mApartmentsStorageMockGetApartmentsInBuilding) Calls() []*ApartmentsStorageMockGetApartmentsInBuildingParams {
	mmGetApartmentsInBuilding.mutex.RLock()

	argCopy := make([]*ApartmentsStorageMockGetApartmentsInBuildingParams, len(mmGetApartmentsInBuilding.callArgs))
	copy(argCopy, mmGetApartmentsInBuilding.callArgs)

	mmGetApartmentsInBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockGetApartmentsInBuildingDone returns true if the count of the GetApartmentsInBuilding invocations corresponds
// the number of defined expectations
func (m *ApartmentsStorageMock) MinimockGetApartmentsInBuildingDone() bool {
	if m.GetApartmentsInBuildingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApartmentsInBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApartmentsInBuildingMock.invocationsDone()
}

// MinimockGetApartmentsInBuildingInspect logs each unmet expectation
func (m *ApartmentsStorageMock) MinimockGetApartmentsInBuildingInspect() {
	for _, e := range m.GetApartmentsInBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ApartmentsStorageMock.GetApartmentsInBuilding with params: %#v", *e.params)
		}
	}

	afterGetApartmentsInBuildingCounter := mm_atomic.LoadUint64(&m.afterGetApartmentsInBuildingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApartmentsInBuildingMock.defaultExpectation != nil && afterGetApartmentsInBuildingCounter < 1 {
		if m.GetApartmentsInBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ApartmentsStorageMock.GetApartmentsInBuilding")
		} else {
			m.t.Errorf("Expected call to ApartmentsStorageMock.GetApartmentsInBuilding with params: %#v", *m.GetApartmentsInBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApartmentsInBuilding != nil && afterGetApartmentsInBuildingCounter < 1 {
		m.t.Error("Expected call to ApartmentsStorageMock.GetApartmentsInBuilding")
	}

	if !m.GetApartmentsInBuildingMock.invocationsDone() && afterGetApartmentsInBuildingCounter > 0 {
		m.t.Errorf("Expected %d calls to ApartmentsStorageMock.GetApartmentsInBuilding but found %d calls",
			mm_atomic.LoadUint64(&m.GetApartmentsInBuildingMock.expectedInvocations), afterGetApartmentsInBuildingCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ApartmentsStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateApartmentInspect()

			m.MinimockDeleteApartmentInspect()

			m.MinimockGetApartmentInspect()

			m.MinimockGetApartmentsInspect()

			m.MinimockGetApartmentsInBuildingInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ApartmentsStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ApartmentsStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateApartmentDone() &&
		m.MinimockDeleteApartmentDone() &&
		m.MinimockGetApartmentDone() &&
		m.MinimockGetApartmentsDone() &&
		m.MinimockGetApartmentsInBuildingDone()
}
